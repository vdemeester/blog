+++
title="Docker 1.6 et son écosystème"
date="2015-06-01"
categories=["zenika"]
tags=["docker","compose","swarm","machine","cluster"]
lang="fr"
+++

<div class="notice">Cet article est disponible sur le <a href="http://blog.zenika.com/">Blog de Zenika</a> à l'adresse suivante : <a href="http://blog.zenika.com/index.php?post/2015/06/01/Docker-1-6-et-son-ecosysteme">http://blog.zenika.com/index.php?post/2015/06/01/Docker-1-6-et-son-ecosysteme</a>. Cet publication me sert de mirroir / sauvegarde.</div>

<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">
<p>
Le 28 octobre dernier, nous avions parlé de la sortie de Docker 1.3, des évolutions entre la version 1 et cette dernière et de son écosystème. Je vous proposes de remettre ça, bientôt 6 mois après, avec un peu le même plan : les principales nouveautés entre la version 1.3 et 1.6 (et il y en a <code>;-)</code>), l'évolution de l'écosystème qui gravite autour et un peu de <i>social</i> avec les meetups et évènements qui se sont passés depuis.
</p>


<div class="figure">
<p><img src="./img/docker-16/docker_container_engine_logo.png" alt="docker_container_engine_logo.png" />
</p>
</div>

<p>
Rappel <i>ultra</i> rapide, <b>Docker est une plate-forme ouverte à destination des développeurs et administrateurs systèmes visant à faciliter la construction et le déploiement d'applications distribuées</b>. De manière moins marketing, l'idée derrière Docker est d'automatiser le déploiement d'environnements sous forme de conteneurs légers, portables et auto-suffisants ; les conteneurs permettant d'isoler l'exécution des applications dans des contextes d'exécution. Pour ce
faire, Docker, écrit en Go, reprend les bases de LXC, utilise les fonctionnalités du noyau Linux (CGroups, Namespaces, …) et se base initialement sur un système de fichier "en oignons" AUFS ; D'autres backends sont supportés également comme BTRFS ou devicemapper (LVM).
</p>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Ovelay filesystem storage driver (1.4.0)</h2>
<div class="outline-text-2" id="text-2">
<p>
La release 1.4.0 de Docker (et la 1.3.3 en parallèle) a surtout été une gigantesque <i>bugfix party</i>, histoire de rendre les fonctionnalités arrivées auparavant plus stable — la release note se trouve <a href="https://github.com/docker/docker/blob/master/CHANGELOG.md#140-2014-12-11">ici</a>.
</p>

<p>
La principale nouveautée de cette version est l'apparation d'un nouveau <i>storage driver</i>, il s'agit d'<b>OverlayFs</b>. Il s'agit d'un mécanisme de montage permettant de superposer dans un répertoire le contenu de plusieurs autres répertoires.
</p>

<p>
Initialement Docker est basé <b><a href="http://en.wikipedia.org/wiki/Aufs">Aufs</a></b> qui fait, pour simplifier, la même chose. Le problème avec aufs est qu'il n'est pas intégré dans le  noyau Linux (i.e. dans les sources officielles), contrairement à OverlayFS qui a fait son apparition avec le noyau <a href="https://git.kernel.org/cgit/linux/kernel/git/torvalds/linux.git/commit/?id=e9be9d5e76e34872f0c37d72e25bc27fe9e2c54c">3.18</a>. Il était donc nécessaire de disposer d'un noyau patché ; Le noyau Linux de Debian et de sess dérivés (Ubuntu, etc.) ont ce <i>patchset</i> aufs de base mais ce n'est pas le cas de toutes les distributions. L'idée de cette intégration est assez simple : supporter le maximum de distributions en se basant sur une <i>feature</i> du noyau. C'est donc bien évidemment le <i>driver</i> d'avenir pour Docker ; attention cependant, la peinture est encore un peu fraîche <code>;-P</code>.
</p>
</div>
</div>

<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Support d'IPv6 (1.5.0)</h2>
<div class="outline-text-2" id="text-3">
<p>
Les adresses IPv4 commencent a se faire <a href="http://en.wikipedia.org/wiki/IPv4_address_exhaustion">rare</a>, il est donc important que Docker supporte IPv6. C'est désormais le cas avec la version 1.5.0, même si ce n'est pas activé par défaut. Pour activer le support de l'IPv6 (en plus de l'IPv4), il faut ajouter le <i>flag</i> <code>--ipv6</code> au daemon. Docker va donc mettre en place le <i>bridge</i> <code>docker0</code> avec en plus un IPv6 en mode local, avec l'adresse <code>fe80::1</code>.
</p>

<p>
Par défaut les containers qui seront créés n'auront qu'une adresse locale. Pour avoir une adresse IPv6 routable à votre conteneur, il est nécessaire de lui préciser un <i>sous-réseau</i> (subnet) dans lequel il va piocher son adresse. Cela se fait grâce à l'argument <code>--fixed-cidr-v6</code>.
</p>


<div class="org-src-container">

<pre class="src src-sh"><span style="color: #783778;">docker</span> <span style="color: #43783f;">-d</span> <span style="color: #374478;">--ipv6</span> <span style="color: #78683f;">--fixed-cidr-v6</span>=<span style="color: #008000;">"2001:db8:1::/64"</span>
</pre>
</div>

<p>
Comme je ne suis pas un pro de l'IPv6, pour plus d'information, et si l'anglais ne vous fait pas peur, c'est dans la <a href="https://docs.docker.com/articles/networking/#ipv6">documentation "networking"</a> de Docker.
</p>
</div>
</div>

<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Conteneurs en lecture seule (1.5.0)</h2>
<div class="outline-text-2" id="text-4">
<p>
Une autre fonctionnalité assez sympathique qui est arrivé avec cette version 1.5.0 est les conteneurs en lecture seule — c'est Michael Crosby qui s'est occupé d'<a href="https://github.com/docker/docker/pull/10093">implémenter ça</a>. L'intérêt des conteneurs en lecture seule est de permettre de <b>contrôler où l'application</b> à l'intérieur de votre conteneur <b>peut écrire ou modifier des fichiers</b>. En combinant ceci avec les volumes, vous pouvez vous assurez des emplacements dans lesquels votre conteneur va persister des états ou données (le/les volumes), puisqu'il ne sera pas possible d'écrire ailleurs de toute façon.
</p>

<p>
Pour activer cette fonctionnalité, c'est l'argument <code>--read-only</code>.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #783778;">docker</span> <span style="color: #513f78;">run</span> <span style="color: #43783f;">--read-only</span> <span style="color: #5e7837;">-v</span> <span style="color: #5e7837;">/volume/writable</span> <span style="color: #3f7178;">busybox</span> <span style="color: #783778;">touch</span> <span style="color: #5e7837;">/volume/writable</span>
</pre>
</div>

<p>
Une autre utilisation des conteneurs en lecture seule est que cela donne la possibilité de faire du debug <i>post-mortem</i> d'un conteneur (en production par exemple). Cela nous permet de redémarrer un conteneur qui aurait planté, en lecture seule avec le système de fichier dans l'état du crash.
</p>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Les labels pour le « daemon », les images et les conteneurs (1.6.0)</h2>
<div class="outline-text-2" id="text-5">
<blockquote>
<p>
One Meta Data to Rule Them All
</p>
</blockquote>

<p>
Une des deux fonctionnalités très attendue de la récente version 1.6.0 sont les labels. En un mot, et pour le faire « à-la » <i>le seigneur des anneaux</i>, les labels peuvent se résumer en "<b>Une metadata pour les gouverner tous</b>" (ça le fait vachement mieux en anglais en fait).
</p>

<p>
Les labels s'appliquent sur le <i>daemon</i>, les images et les conteneurs. C'est un peu un mélange entre des tags et des variables d'environnements puisque il s'agit d'un couple <b>clé/valeur</b>.
</p>

<p>
L'ajout de label sur le <i>daemon</i> se fait grâce à l'argument — roulement de tambour — <code>--label</code> (<code>\o/</code>). La principale utilité pour l'instant est son utilisation conjointe avec Swarm dont nous parlerons un peu plus bas ; mais en deux mots, cela permet de filtrer les <i>engines</i> sur lesquels on va <i>taper</i>.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Souvent, c'est dans DOCKER_OPTS du fichier /etc/default/docker</span>
<span style="color: #783778;">docker</span> <span style="color: #43783f;">-d</span> <span style="color: #784437;">-H</span> <span style="color: #4f5c7e;">unix://var/run/docker.sock</span> <span style="color: #7a4f7e;">--label</span> <span style="color: #BA36A5;">storage</span>=<span style="color: #5e7837;">ssd</span> <span style="color: #7a4f7e;">--label</span> <span style="color: #BA36A5;">type</span>=<span style="color: #5e7837;">laptop</span>
</pre>
</div>

<p>
L'ajout d'un label sur une image se fait dans le fichier <code>Dockerfile</code>, et l'ajout d'un label sur un conteneur, grâce à l'argument <code>--label</code> pour rester cohérent. Construisons une image inutile mais en lui appliquant un label :
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #37785e;">FROM</span> <span style="color: #3f7178;">busybox</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Support du multi-line pour LABEL</span>
<span style="color: #783778;">LABEL</span> <span style="color: #BA36A5;">vendor</span>=<span style="color: #78683f;">zenika</span> <span style="color: #008000;">\</span>
      <span style="color: #784437;">com.zenika.lang</span>=<span style="color: #374478;">golang</span> <span style="color: #008000;">\</span>
      <span style="color: #78683f;">com.zenika.version</span>=<span style="color: #43783f;">0.1</span>
<span style="color: #7a4f7e;">CMD</span> [<span style="color: #008000;">"echo"</span><span style="color: #7e544f;">,</span> <span style="color: #008000;">"zenika"</span>]
</pre>
</div>

<p>
Nous allons maintenant construire cette image et lancer un conteneur à partir de cette dernière avec un autre label.
</p>

<div class="org-src-container">

<pre class="src src-sh">$ <span style="color: #783778;">docker</span> <span style="color: #7e544f;">build</span> <span style="color: #7a4f7e;">-t</span> <span style="color: #4f7e67;">zenikaapp</span> <span style="color: #374478;">.</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">[&#8230;]</span>
$ <span style="color: #783778;">docker</span> <span style="color: #513f78;">run</span> <span style="color: #4f5c7e;">--name</span> <span style="color: #783f5a;">test</span> <span style="color: #7a4f7e;">--label</span> <span style="color: #783f5a;">com.zenika.foo</span>=<span style="color: #784437;">bar</span> <span style="color: #4f7e67;">zenikaapp</span>
<span style="color: #78683f;">zenika</span>
</pre>
</div>

<p>
L'idée c'est que maintenant, lorsque l'on va regarder la liste d'images ou de conteneurs à disposition sur notre <i>engine</i>, nous allons pouvoir <b>filtrer</b> par label, comme suit :
</p>

<div class="org-src-container">

<pre class="src src-sh">$ <span style="color: #783778;">docker</span> <span style="color: #707e4f;">images</span> <span style="color: #4f5c7e;">--filter</span> <span style="color: #008000;">"label=vendor=zenika"</span> <span style="color: #4f5c7e;">--filter</span> <span style="color: #008000;">"label=com.zenika.lang=golang"</span>
<span style="color: #784437;">REPOSITORY</span>          <span style="color: #3f7178;">TAG</span>                 <span style="color: #707e4f;">IMAGE</span> <span style="color: #707e4f;">ID</span>            <span style="color: #7e544f;">CREATED</span>             <span style="color: #784437;">VIRTUAL</span> <span style="color: #4f7e67;">SIZE</span>
<span style="color: #4f7e67;">zenikaapp</span>           <span style="color: #7a4f7e;">latest</span>              <span style="color: #784437;">66ffda023118</span>        <span style="color: #5e7837;">43</span> <span style="color: #7e544f;">seconds</span> <span style="color: #43783f;">ago</span>      <span style="color: #783778;">2.433</span> <span style="color: #7e544f;">MB</span>
$ <span style="color: #783778;">docker</span> <span style="color: #43783f;">ps</span> <span style="color: #784437;">-a</span> <span style="color: #4f5c7e;">--filter</span> <span style="color: #008000;">"label=com.zenika.foo=bar"</span>
<span style="color: #374478;">CONTAINER</span> <span style="color: #707e4f;">ID</span>        <span style="color: #707e4f;">IMAGE</span>               <span style="color: #78683f;">COMMAND</span>             <span style="color: #7e544f;">CREATED</span>              [<span style="color: #374478;">&#8230;</span>]   <span style="color: #707e4f;">NAMES</span>
<span style="color: #513f78;">37e9a37caf57</span>        <span style="color: #513f78;">zenikaapp:latest</span>    <span style="color: #008000;">"echo zenika"</span>       <span style="color: #43783f;">About</span> <span style="color: #78683f;">a</span> <span style="color: #37785e;">minute</span> <span style="color: #43783f;">ago</span>   [<span style="color: #374478;">&#8230;</span>]   <span style="color: #783f5a;">test</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">On peut &#233;galement regarder les labels avec inspect</span>
$ <span style="color: #783778;">docker</span> <span style="color: #374478;">inspect</span> <span style="color: #3f7178;">-f</span> <span style="color: #008000;">"{{json .ContainerConfig.Labels }}"</span> <span style="color: #783f5a;">zenikaap</span>
{<span style="color: #008000;">"com.zenika.lang"</span><span style="color: #707e4f;">:</span><span style="color: #008000;">"golang"</span><span style="color: #7e544f;">,</span><span style="color: #008000;">"com.zenika.version"</span><span style="color: #707e4f;">:</span><span style="color: #008000;">"0.1"</span><span style="color: #7e544f;">,</span><span style="color: #008000;">"vendor"</span><span style="color: #707e4f;">:</span><span style="color: #008000;">"zenika"</span>}
$ <span style="color: #783778;">docker</span> <span style="color: #374478;">inspect</span> <span style="color: #3f7178;">-f</span> <span style="color: #008000;">"{{json .Config.Labels }}"</span> <span style="color: #783f5a;">test</span>
{<span style="color: #008000;">"com.zenika.foo"</span><span style="color: #707e4f;">:</span><span style="color: #008000;">"bar"</span><span style="color: #7e544f;">,</span><span style="color: #008000;">"com.zenika.lang"</span><span style="color: #707e4f;">:</span><span style="color: #008000;">"golang"</span><span style="color: #7e544f;">,</span><span style="color: #008000;">"com.zenika.version"</span><span style="color: #707e4f;">:</span><span style="color: #008000;">"0.1"</span><span style="color: #7e544f;">,</span><span style="color: #008000;">"vendor"</span><span style="color: #707e4f;">:</span><span style="color: #008000;">"zenika"</span>}
</pre>
</div>

<p>
On peut imaginer beaucoup d'usage de ces labels. Par example, avec <a href="http://rancher.com">Rancher</a>, ils sont utilisés pour faciliter la configuration du load-balancer (<a href="http://rancher.com/docker-labels/">ici</a>) — ils utilisent un label <code>io.rancher.service.provides</code> qui permettra à ce dernier de trouver automatiquement ces petits. Je vous laisse imaginer vos propres <i>use-cases</i>.
</p>

<p>
Il y a une partie de la documentation qui parle exclusivement des labels, avec une petite partie sur les <i>best-practice</i> de nommage des labels, c'est <a href="https://docs.docker.com/userguide/labels-custom-metadata/">ici</a>.
</p>
</div>
</div>

<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Logging drivers \o/ (1.6.0)</h2>
<div class="outline-text-2" id="text-6">
<p>
Un <i>gros reproche</i> qui était fait à Docker était sa gestion très <b>simpliste</b> des logs des conteneurs. Plusieurs critiques étaient faites :
</p>

<ol class="org-ol">
<li>Tout faire sortir sur <code>stdout</code> et <code>stderr</code> n'est pas vraiment une habitude de nos jours, surtout dans des langages comme Java où l'utilisation de <i>logger</i> (Log4j, Slf4j, …) est très répandue. Cela rend le portage vers docker de certaines applications un peu plus fastidieux.
</li>
<li>Il n'y avait aucun mécanisme de <i>rotation</i> de logs — et comme en plus le dossier dans lequel les logs étaient écris est un peu enfoui dans <code>/var/lib/docker</code>, cela pouvait poser quelques problème si des conteneurs étaient un peu trop bavards..
</li>
<li>La solution utilisée pour sauvegarder ces logs et pourquoi pas les centraliser (avec ELK par exemple), était d'utiliser un volume, souvent partagé entre applications, et de démarrer un conteneur pour gérer cette analyse, centralisation, …. Non seulement ce n'est pas très optimal, mais cela nécessitait de configurer chaque application (donc chaque conteneur) — et <code>docker logs</code> perdait tout son intérêt.
</li>
</ol>

<p>
Avec la version 1.6.0, les <i>logging driver</i> permettent une gestion des logs un peu plus optimale, ou au moins plus flexible. Il est donc maintenant possible de préciser le <i>logging driver</i> à utiliser. Ils en existent 3 pour l'instant :
</p>

<ol class="org-ol">
<li><code>json-file</code> correspond au comportement par défaut de Docker avant la 1.6 et reste la valeur par défaut
</li>
<li><code>syslog</code> qui permet de connecter les logs de nos conteneurs dans notre vénérable syslog (ou en tout cas quelqu'un qui parl le syslog).
</li>
<li><code>none</code> qui est le magicien puisqu'il nous permet de faire taire complètement un conteneur <code>o/</code>.
</li>
</ol>

<p>
Il est possible de définir le logging driver à deux endroits :
</p>

<ol class="org-ol">
<li>sur le <b>daemon</b> pour la valeur par défaut de tous les conteneurs.
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">$ <span style="color: #783778;">docker</span> <span style="color: #43783f;">-d</span> <span style="color: #5e7837;">--log-driver</span>=<span style="color: #008000;">"json-file"</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Pour faire taire les conteneurs par d&#233;faut</span>
$ <span style="color: #783778;">docker</span> <span style="color: #43783f;">-d</span> <span style="color: #5e7837;">--log-driver</span>=<span style="color: #008000;">"none"</span>
</pre>
</div>

<ol class="org-ol">
<li>en option de la command <b>run</b> (ou de la commande <b>create</b>).
</li>
</ol>

<div class="org-src-container">

<pre class="src src-sh">$ <span style="color: #783778;">docker</span> <span style="color: #513f78;">run</span> <span style="color: #5e7837;">--log-driver</span>=<span style="color: #3f7178;">syslog</span> <span style="color: #3f7178;">ubuntu</span> <span style="color: #008000;">\</span>
  <span style="color: #37785e;">/bin/bash</span> <span style="color: #784437;">-c</span> <span style="color: #008000;">'while true; do echo "Hello"; sleep1; done'</span>
$ <span style="color: #707e4f;">tail</span> <span style="color: #3f7178;">-f</span> <span style="color: #784437;">/var/log/syslog</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">[&#8230;]</span>
<span style="color: #374478;">May</span> <span style="color: #3f7178;">28</span> <span style="color: #3f7178;">17:39:01</span> <span style="color: #7e544f;">dev1</span> <span style="color: #783778;">docker</span>[<span style="color: #5e7837;">116314</span>]<span style="color: #707e4f;">:</span> <span style="color: #513f78;">0e5b67244c00:</span> <span style="color: #4f7e67;">Hello</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">[&#8230;]</span>
</pre>
</div>

<p>
Une option <code>--log-opts</code> est également présente pour passer des options additionnelles au driver si celui-ci les supporte. Notons également qu'un driver pour <code>systemd</code> devrait arriver avec la version 1.7.
</p>

<p>
La pull-request ayant permis d'intégrer cette fonctionnalité se trouve <a href="https://github.com/docker/docker/pull/10568">ici</a>.
</p>
</div>
</div>

<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Client Windows natif (1.6.0)</h2>
<div class="outline-text-2" id="text-7">
<p>
Enfin, on s'en doutait un peu après l'annonce du partenariat entre Docker Microsoft, ça bosse beaucoup pour porter Docker vers Windows. La première étape était de fournir un client natif pour Windows. C'est chose faite avec cette version 1.6. Maintenant beaucoup de travail est effectué pour rendre le <i>engine</i> plus portable, il n'y a qu'à suivre un peu les pull-request avec un tag <code>os/windows</code> ou encore cette très récente pull-request avec un titre plutôt évocateur : « <a href="https://github.com/docker/docker/pull/13554">Windows: The real Windows exec driver is here</a> ».
</p>
</div>
</div>

<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Divers</h2>
<div class="outline-text-2" id="text-8">
<p>
Il y a pas mal d'autres options qui sont arrivées depuis la version 1.3.0, nous allons en parcourir certaines rapidement — parce que sinon cet article va faire 100 pages ;-p :
</p>

<ul class="org-ul">
<li><b>Stats</b> (1.5.0) : une commande <code>stats</code> (et donc une API derrière) permet de récupérer quelques statistiques par conteneur, c'est simple pour l'instant.
</li>
<li>Depuis la version 1.5.0 il est possible de spécifier le ficher Dockerfile grâce à l'option <code>-f</code> de la commande build — jusqu'à maintenant docker regardait uniquement le dossier spécifié et cherchait le fichier <code>Dockerfile</code>. Cela permet donc, par exemple, d'avoir plusieurs <code>Dockerfile</code> dans un dossier.
</li>
</ul>

<div class="org-src-container">

<pre class="src src-sh">$ <span style="color: #783778;">docker</span> <span style="color: #7e544f;">build</span> <span style="color: #7a4f7e;">-t</span> <span style="color: #5e7837;">monimage</span> <span style="color: #3f7178;">-f</span> <span style="color: #43783f;">backend.Dockerfile</span> <span style="color: #374478;">.</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">[&#8230;] Build the backend</span>
$ <span style="color: #783778;">docker</span> <span style="color: #7e544f;">build</span> <span style="color: #7a4f7e;">-t</span> <span style="color: #5e7837;">monimage</span> <span style="color: #3f7178;">-f</span> <span style="color: #4f7e67;">frontend.Dockerfile</span> <span style="color: #374478;">.</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">[&#8230;] Build the frontend</span>
</pre>
</div>

<ul class="org-ul">
<li>Le <i>registry</i> voit son API passer en V2, principalement pour améliorer les transferts. L'implémentation officielle a été réécrite en Go (à la place de Python) et se nomme maintenant <a href="https://github.com/docker/distribution">distribution</a>.
</li>
<li>La commande <code>commit est dotée, depuis la version 1.6.0, d'une option =--change</code> qui permet d'appliquer une instruction supportée par les <code>Dockerfile</code> — voir <a href="https://docs.docker.com/reference/commandline/cli/#commit">ici</a>.
</li>
<li>Docker a publié un petit document « <a href="https://github.com/docker/docker/blob/master/image/spec/v1.md">Docker Image Specification</a> » qui a pour but de définir le format des images utilisées par Docker, permettant à d'autres notamment des potentiels conccurents, d'implémenter des images qui seraient compatible.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">À venir</h2>
<div class="outline-text-2" id="text-9">
<p>
L'une des principales nouveautés qui devrait arriver avec la version 1.7 de Docker, c'est l'intégration d'une <b>nouvelle stack réseau</b> avec l'intégration du projet <a href="https://github.com/docker/libnetwork">libnetwork</a>, si tout se passe bien. On pourra noter également de nouveaux <i>logging driver</i>, avec notamment un <code>rollover</code> driver ou encore le <code>systemd</code> driver. On peut noter également l'arrivée d'un <i>filesystem driver</i> pour ZFS (voici la <a href="https://github.com/docker/docker/pull/9411">pull-request</a>). Le Docker Birthday étant passé par là, beaucoup de corrections de bugs, de nouvelles petites fonctionnalités, une meilleure couverture de code par les tests unitaires (<code>o/</code>).
</p>

<p>
La RC1 est disponible depuis le 28 mai, <a href="https://github.com/docker/docker/releases/tag/v1.7.0-rc1">ici</a> et la <a href="https://github.com/docker/docker/pull/13528">pull-request</a> associée, donc à vos tests !
</p>
</div>
</div>

<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Écosystème</h2>
<div class="outline-text-2" id="text-10">
<p>
Trois projets « Docker » sont apparus depuis le dernier article : Compose, Swarm et Machine. Présentons les très rapidement.
</p>
</div>

<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">Compose</h3>
<div class="outline-text-3" id="text-10-1">
<p>
Compose est le nouveau nom de Fig. Fig était développé par Orchard qui a été racheté par Docker. Pour rappel, l'idée est de définir son environnement via un fichier YAML, que ce soit pour le code sur lequel nous travaillons mais également les services externes desquels notre application dépend (Base de données, ''Message queue'', etc.).
</p>

<div class="org-src-container">

<pre class="src src-yaml"><span style="color: #BA36A5;">web</span>:
  <span style="color: #BA36A5;">build</span>: .
  <span style="color: #BA36A5;">command</span>: lein run
  <span style="color: #BA36A5;">links</span>:
   - db
  <span style="color: #BA36A5;">ports</span>:
   - <span style="color: #008000;">"8000:8000"</span>
<span style="color: #BA36A5;">db</span>:
  <span style="color: #BA36A5;">image</span>: postgres
</pre>
</div>

<p>
Compose est en version 1.2 — depuis la version 1.0, la majorité des modifications sont des corrections de bugs et des ajouts pour suivre les modifications et nouvelles fonctionnalités de Docker (<code>env-file</code>, <code>dns_search</code>, <code>add_host</code>, <code>restart</code>, <code>volumes_from</code>, <code>net</code>, …). La commande est maintenant <code>docker-compose</code> à la place de <code>fig</code> et le fichier <code>docker-compose.yml</code> à la place de <code>fig.yml</code> — pour des raisons de rétro-compatibilité, Compose continue de lire les <code>fig.yml</code>.
</p>
</div>
</div>

<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">Swarm &amp; Machine</h3>
<div class="outline-text-3" id="text-10-2">
<p>
Deux nouveaux projets ont fait leur apparition dans l'escarcelle de Docker Inc. : Swarm et Machine. Swarm est le <i>clustering</i> à moyenne échelle vu par Docker. Machine permet de provisionner Docker sur différents providers : amazon aws, google compute engine, azure, Virtualbox pour ne citer qu'eux — mais beaucoup d'autres sont déjà supportés.
</p>

<p>
Voilà ce que Jérôme Petazzoni dit à propos de Swarm :
</p>

<blockquote>
<p>
Un système de cluster utilisant l’API Docker et compatible avec tous les outils de l’écosystème maison. On peut utiliser les commandes classiques Docker pour piloter le cluster
</p>
</blockquote>

<p>
L'idée principale de Swarm est <b>Je veux parler à mon cluster Docker de la même façon que je parle avec mon daemon Docker</b>. Cela se traduit assez simplement par : <b>Swarm expose la même API que docker</b>. C'est une idée simple et terriblement puissante puisque cela veut dire que je peux administrer mon cluster avec les mêmes commandes que j'utilise quand je travaille en local.  Swarm a pour but de piloter des clusters d'une taille relativement petite (moins de 1000 machines). Pour les clusters de plus grande taille, il existe de très bonnes solutions, comme <a href="http://mesos.apache.org/">Mesos</a>, et ce n'est pas le but de Docker Inc. de venir les concurrencer, bien au contraire.
</p>

<p>
Pour faire simple, swarm c'est un <b>manager</b> et des <b>agents</b> (un par engine) — les agents s'enregistrent auprès du master par le biais d'un <i>service discovery</i>. Swarm dispose d'un petit service de discovery mais qui n'est là que pour <i>la démo</i> ; il est possible et conseillé de le connecter à des solutions existantes, pour l'instant <a href="https://github.com/hashicorp/consul">consul</a> et <a href="https://github.com/coreos/etcd">etcd</a>.
</p>

<p>
Un bout de code vaut mieux qu'un long discours, voici comment <i>bootstraper</i> un cluster Swarm, avec l'aide de Machine pour être <i>funky</i>.
</p>

<div class="org-src-container">

<pre class="src src-sh"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">On cr&#233;e un cluster simple avec son id</span>
$ <span style="color: #7a4f7e;">swarm</span> <span style="color: #783f5a;">create</span>
<span style="color: #3f7178;">50862dcedd53c2f584adfb00e85bac4b</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">On d&#233;marre des agents</span>
$ <span style="color: #43783f;">docker-machine</span> <span style="color: #783f5a;">create</span> <span style="color: #43783f;">-d</span> <span style="color: #374478;">azure</span> <span style="color: #4f5c7e;">--swarm</span> <span style="color: #4f5c7e;">--swarm-discovery</span> <span style="color: #4f7e67;">token://50862dcedd53c2f584adfb00e85bac4b</span> <span style="color: #43783f;">node1</span>
<span style="color: #3f7178;">INFO</span>[<span style="color: #7a4f7e;">0000</span>] <span style="color: #5e7837;">Creating</span> <span style="color: #513f78;">SSH</span> <span style="color: #5e7837;">key...</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">[&#8230;]</span>
$ <span style="color: #43783f;">docker-machine</span> <span style="color: #783f5a;">create</span> <span style="color: #43783f;">-d</span> <span style="color: #7e544f;">digitalocean</span> <span style="color: #4f5c7e;">--swarm</span> <span style="color: #4f5c7e;">--swarm-discovery</span> <span style="color: #4f7e67;">token://50862dcedd53c2f584adfb00e85bac4b</span> <span style="color: #783f5a;">node2</span>
<span style="color: #3f7178;">INFO</span>[<span style="color: #7a4f7e;">0000</span>] <span style="color: #5e7837;">Creating</span> <span style="color: #513f78;">SSH</span> <span style="color: #5e7837;">key...</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">[&#8230;]</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">On d&#233;marre le master</span>
$ <span style="color: #43783f;">docker-machine</span> <span style="color: #783f5a;">create</span> <span style="color: #43783f;">-d</span> <span style="color: #78683f;">virtualbox</span> <span style="color: #4f5c7e;">--swarm</span> <span style="color: #707e4f;">--swarm-master</span> <span style="color: #4f5c7e;">--swarm-discovery</span> <span style="color: #4f7e67;">token://50862dcedd53c2f584adfb00e85bac4b</span> <span style="color: #374478;">manager</span>
</pre>
</div>

<p>
Maintenant que l'on dispose d'un petit cluster, en pointant dessus (merci Machine) on va pouvoir lancer des commandes docker.
</p>

<div class="org-src-container">

<pre class="src src-sh">$ $(<span style="color: #43783f;">docker-machine</span> <span style="color: #7a4f7e;">env</span> <span style="color: #4f5c7e;">--swarm</span> <span style="color: #374478;">manager</span>)
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">Le bon vieux info</span>
$ <span style="color: #783778;">docker</span> <span style="color: #784437;">info</span>
<span style="color: #3f7178;">Containers:</span> <span style="color: #4f5c7e;">4</span>
<span style="color: #4f5c7e;">Nodes:</span> <span style="color: #7e544f;">3</span>
 <span style="color: #374478;">manager:</span> <span style="color: #7e544f;">192.168.99.103:2376</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #3f7178;">Containers:</span> <span style="color: #513f78;">2</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #4f7e67;">Reserved</span> <span style="color: #4f5c7e;">CPUs:</span> <span style="color: #784437;">0</span> <span style="color: #783778;">/</span> <span style="color: #4f5c7e;">4</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #4f7e67;">Reserved</span> <span style="color: #7a4f7e;">Memory:</span> <span style="color: #784437;">0</span> <span style="color: #4f7e67;">B</span> <span style="color: #783778;">/</span> <span style="color: #707e4f;">999.9</span> <span style="color: #783f5a;">MiB</span>
 <span style="color: #78683f;">node1:</span> <span style="color: #513f78;">45.55.160.223:2376</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #3f7178;">Containers:</span> <span style="color: #78683f;">1</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #4f7e67;">Reserved</span> <span style="color: #4f5c7e;">CPUs:</span> <span style="color: #784437;">0</span> <span style="color: #783778;">/</span> <span style="color: #78683f;">1</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #4f7e67;">Reserved</span> <span style="color: #7a4f7e;">Memory:</span> <span style="color: #784437;">0</span> <span style="color: #4f7e67;">B</span> <span style="color: #783778;">/</span> <span style="color: #4f7e67;">490</span> <span style="color: #783f5a;">MiB</span>
 <span style="color: #513f78;">node2:</span> <span style="color: #707e4f;">swarm-nwde2.cloudapp.net:2376</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #3f7178;">Containers:</span> <span style="color: #78683f;">1</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #4f7e67;">Reserved</span> <span style="color: #4f5c7e;">CPUs:</span> <span style="color: #784437;">0</span> <span style="color: #783778;">/</span> <span style="color: #78683f;">1</span>
  <span style="color: #78683f;">&#9492;</span> <span style="color: #4f7e67;">Reserved</span> <span style="color: #7a4f7e;">Memory:</span> <span style="color: #784437;">0</span> <span style="color: #4f7e67;">B</span> <span style="color: #783778;">/</span> <span style="color: #7e544f;">1.639</span> <span style="color: #3f7178;">GiB</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">On d&#233;marre des nginx</span>
$ <span style="color: #4f7e67;">for</span> <span style="color: #7a4f7e;">i</span><span style="color: #0000FF;"> in</span> <span style="color: #FF1493;">`seq 1 3`</span>; <span style="color: #0000FF;">do</span> <span style="color: #783778;">docker</span> <span style="color: #513f78;">run</span> <span style="color: #43783f;">-d</span> <span style="color: #783f5a;">-p</span> <span style="color: #7a4f7e;">80:80</span> <span style="color: #783778;">nginx</span>; <span style="color: #0000FF;">done</span>
$ <span style="color: #783778;">docker</span> <span style="color: #43783f;">ps</span>
<span style="color: #374478;">CONTAINER</span> <span style="color: #707e4f;">ID</span>    <span style="color: #707e4f;">IMAGE</span>       <span style="color: #78683f;">COMMAND</span>                <span style="color: #78683f;">...</span> <span style="color: #3f7178;">PORTS</span>                                <span style="color: #707e4f;">NAMES</span>
<span style="color: #374478;">9bff07d8ee18</span>    <span style="color: #78683f;">nginx:1.7</span>   <span style="color: #008000;">"nginx -g 'daemon of   ... 443/tcp, 104.210.33.180:80-&gt;80/tcp   node1/loving_torvalds</span>
<span style="color: #008000;">457ed59c9bb3    nginx:1.7   "</span><span style="color: #783778;">nginx</span> <span style="color: #78683f;">-g</span> <span style="color: #008000;">'daemon of   ... 443/tcp, 45.55.160.223:80-&gt;80/tcp    node2/drunk_swartz</span>
<span style="color: #008000;">6013be18cdbc    nginx:1.7   "nginx -g '</span><span style="color: #3f7178;">daemon</span> <span style="color: #5e7837;">of</span>   <span style="color: #78683f;">...</span> <span style="color: #784437;">443/tcp,</span> <span style="color: #4f7e67;">192.168.99.103:80-</span>&gt;<span style="color: #5e7837;">80/tcp</span>   <span style="color: #707e4f;">manager/condescending_galileo</span>
</pre>
</div>

<p>
On voit qu'on a démarré nginx sur les 3 nœuds. Swarm a quelques stratégies pour démarrer un conteneur sur un nœud ou l'autre :
</p>

<ul class="org-ul">
<li><code>spread</code> va éparpiller les conteneurs pour que chaque nœud en ait le moins possible (répartis).
</li>
<li><code>binpack</code> va faire l'inverse (tout sur le même nœud jusqu'à ce que ses ressources soient épuisés).
</li>
<li><code>random</code> qui fait <i>au pif</i>.
</li>
</ul>

<p>
Il est également possible de mettre des contraintes lors du lancement d'un conteneur, en utilisant le flag <code>-e</code> de <code>docker run</code> (<code>-e</code> = variables d'environnement).
</p>


<div class="org-src-container">

<pre class="src src-sh"><span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">D&#233;marrer postgres sur un host qui a le label storage=ssd</span>
$ <span style="color: #783778;">docker</span> <span style="color: #513f78;">run</span> <span style="color: #43783f;">-d</span> <span style="color: #707e4f;">-e</span> <span style="color: #4f5c7e;">constraint:</span><span style="color: #4f5c7e;">storage</span>==<span style="color: #5e7837;">ssd</span> <span style="color: #4f5c7e;">--name</span> <span style="color: #4f7e67;">postgres</span> <span style="color: #4f7e67;">postgres</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">D&#233;marrer redis &#224; cot&#233; du conteneur dont le nom est postgres</span>
$ <span style="color: #783778;">docker</span> <span style="color: #513f78;">run</span> <span style="color: #43783f;">-d</span> <span style="color: #707e4f;">-e</span> <span style="color: #4f5c7e;">affinity:</span><span style="color: #4f5c7e;">container</span>==<span style="color: #4f7e67;">postgres</span> <span style="color: #4f5c7e;">--name</span> <span style="color: #7e544f;">redis</span> <span style="color: #7e544f;">redis</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">D&#233;marer backend o&#249; tu veux, mais comme les links sont des contraintes</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">implicites il d&#233;marrera sur le m&#234;me host que postgres ET redis</span>
<span style="color: #8D8D84;"># </span><span style="color: #8D8D84; font-style: italic;">(ou ne d&#233;marrera pas ces derniers ne sont pas au m&#234;me endroit)</span>
$ <span style="color: #783778;">docker</span> <span style="color: #513f78;">run</span> <span style="color: #43783f;">-d</span> <span style="color: #374478;">--link</span> <span style="color: #3f7178;">redis:redis</span> <span style="color: #374478;">--link</span> <span style="color: #784437;">postgres:db</span> <span style="color: #4f5c7e;">--name</span> <span style="color: #78683f;">backend</span> <span style="color: #78683f;">backend</span>
</pre>
</div>

<p>
On pourrait faire un article dédié à Swarm (ce qui sera probablement le cas dans un avenir assez proche) donc je vous laisse le découvrir via <a href="https://github.com/docker/swarm/">github</a>.
</p>
</div>
</div>
</div>

<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Levées de fonds et acquisitons</h2>
<div class="outline-text-2" id="text-11">
<p>
Docker est sur toutes les lèvres en ce moment. Il est donc normal que cela attire également des capitaux. Le 14 avril dernier, Docker annonçait une nouvelle levée de fonds de <b>95 millions</b> de dollars. Après celle de <i>40 millions</i> en Septembre 2014, on peut se dire que Docker Inc. a de beaux jours à venir.
</p>

<p>
Docker Inc. « mange » aussi quelques startups, puisque après Orchard, qui éditait fig (devenu docker-compose), ils ont fait l'acquisition de <a href="http://socketplane.io/">Socketplane</a> et <a href="https://kitematic.com/">Kitematic</a>. Kitematic est un outil <i>desktop</i> qui permet de facilement utiliser Docker sous Mac OS X, une belle application, un peu « clickodrome » <code>;-P</code>. <a href="http://socketplane.io/">Socketplane</a> est une solution réseau qui connectait Open vSwitch avec Docker — nulle doute que la récente libnetwork vient de là.
</p>
</div>
</div>

<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Évènements</h2>
<div class="outline-text-2" id="text-12">
<p>
Nous allons finir avec une liste non-exhaustive et un peu orientée des évènements <i>marquants</i> qui se sont passés ces derniers mois :
</p>

<ul class="org-ul">
<li>Le <a href="https://blog.docker.com/2014/11/docker-tour-de-france/">Docker Tour de France</a>, avec notament un <a href="http://www.meetup.com/Docker-Paris/events/218767688/">hackathon</a> organisé à l'<a href="http://www.epitech.eu/paris/ecole-informatique-paris.aspx">Epitech</a>, où notre <a href="https://twitter.com/mariolet">Mario Loriedo</a> national a bootstrapé son projet Sublime-docker avec <a href="https://github.com/mjbright">Mike Bright</a> et à du coup gagné sa place à la DockerCon de 2015.
</li>
<li>Les <a href="http://blog.zenika.com/index.php?post/2015/02/19/NightClazz-Docker-Avance">Nightclazz</a> <a href="http://zenika.github.io/NC-Docker-Decouverte/">découverte</a> et <a href="http://zenika.github.io/NC-Docker-Avance/#/">avancée</a> hébergé par Zenika, présenté par Mario Loriedo et moi-même ;-).
</li>
<li>La DockerCon Europe.
</li>
<li>Le <a href="http://docker.party/">Docker Birthday</a>, gigantesque <i>Open-source-athon</i> tout autour du monde — une véritable réussite, tant au niveau de l'organisation (des évènements, la préparation en amont des <i>issues</i>, etc.) que de ce qu'il en est <a href="https://blog.docker.com/2015/05/dockers-2nd-birthday-by-the-numbers/">ressorti</a>.
</li>
</ul>
</div>
</div>
