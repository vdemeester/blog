#+hugo_base_dir: ../
#+hugo_section: posts
#+seq_todo: TODO DRAFT NONE

#+options: creator:t

* Series
** Golang testing                             :@developement:testing:golang:
*** Golang testing — gotest.tools introduction                   :featured:
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-07-28-gotest-tools-intro
:EXPORT_DATE: 2018-07-28
:END:

#+begin_description
I already wrote 2 previous posts about golang and testing. It's something I care deeply about and I wanted to continue
writing about it. It took me a bit more time than I thought, but getting back to it. Since the [[http://vincent.demeester.fr/posts/2017-04-22-golang-testing-golden-file/][last post]], Daniel Nephin
and I worked (but mainly Daniel 🤗) on bootstrapping a testing helper library.
#+end_description

Let me introduce it to you this library : [[https://gotest.tools][=gotest.tools=]]. As described in the [[https://godoc.org/gotest.tools][godoc]] package comment, =gotest.tools= is a
collection of packages to augment =testing= and support common patterns. It's an enhanced and growing version of the
initial helpers we (the docker/moby maintainers) wrote initially in [[https://github.com/docker/docker][=docker/docker=]] repository. We are using in quite some
project here at [[https://github.com][Docker]].

There is a bunch of packages that will all have their own post (linked here when available) :

- [[/posts/2018-08-16-gotest-tools-assertions/][=assert=]] (with =assert/cmp= and =assert/opt=) that provides assertions for comparing expected values to actual values.
- =env= that provides functions to test code that read environment variable or the current working directory.
- [[/posts/2018-09-14-gotest-tools-fs/][=fs=]] that provides tools for creating temporary files, and testing the contents and structure of a directory.
- [[/posts/2018-09-06-gotest-tools-golden/][=golden=]] that provides tools for comparing large multi-line strings.
- [[/posts/2018-09-18-gotest-tools-icmd/][=icmd=]] that executes binaries and provides convenient assertions for testing the results.
- =poll= that provides tools for testing asynchronous code.
- [[/posts/2018-09-01-gotest-tools-skip/][=skip=]] that provides functions for skipping a test and printing the source code of the condition used to skip the test.

There is also experimental package, using the =x= notation (as the golang team uses, for example with =golang.org/x/sync=) :

- =x/subtest= that provides a =TestContext= to subtests which handles cleanup and provides a =testing.TB= and =context.Context=.

There is already some good =testing= helpers in the Go ecosystem : [[https://github.com/stretchr/testify][=testify=]], [[http://labix.org/gocheck][=gocheck=]], [[https://github.com/onsi/ginkgo][=ginkgo=]] and a lot more — so
why create a new one ? There is multiple reason for it, most of them can be seen in the following [[https://github.com/gotestyourself/gotest.tools/issues/49#issuecomment-362436026][GitHub issue]].

[[https://github.com/dnephin/][Daniel]] also wrote a very useful converter if your code base is currently using =testify= : =gty-migrate-from-testify=.

#+BEGIN_SRC sh
$ go get -u gotest.tools/assert/cmd/gty-migrate-from-testify
# […]
$ go list \
     -f '{{.ImportPath}} {{if .XTestGoFiles}}{{"\n"}}{{.ImportPath}}_test{{end}}' \
     ./... | xargs gty-migrate-from-testify
#+END_SRC

In the next post, let's dig into the assertion part of the library, package =assert= 👼.

*** Golang testing — gotest.tools assertions                       :assert:
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-08-16-gotest-tools-assertions
:EXPORT_DATE: 2018-08-16
:EXPORT_OPTIONS: toc:t
:END:

#+begin_description
Faster way to send the same command to each and every /pane/ in your
tmux /session/.


Let's take a closer look at [[https://gotest.tools][=gotest.tools=]] assertions packages. This is mainly about =assert=, =assert/cmp= and
=assert/opt=.

#+BEGIN_QUOTE
Package assert provides assertions for comparing expected values to actual values. When assertion fails a helpful error
message is printed.
#+END_QUOTE

There is two main functions (=Assert= and =Check=) and some helpers (like =NilError=, …). They all take a =*testing.T= as
a first argument, pretty common across testing Go libraries. Let's dive into those !
#+end_description

**** =Assert= and =Check=

Both those functions accept a =Comparison= (we'll check what it is later on) and fail the test when that comparison
fails. The one difference is that =Assert= will end the test execution at immediately whereas =Check= will fail the test
and proceed with the rest of the test case. This is similar to =FailNow= and =Fail= from the standard library
=testing=. Both have their use cases.

We'll Use =Assert= for the rest of the section but any example here would work with =Check= too. When we said
=Comparison= above, it's mainly the [[https://godoc.org/gotest.tools/assert#BoolOrComparison][BoolOrComparison]] interface — it can either be a boolean expression, or a
[[https://godoc.org/gotest.tools/assert/cmp#Comparison][cmp.Comparison]] type. =Assert= and =Check= code will be /smart/ enough to detect which one it is.

#+BEGIN_SRC go
  assert.Assert(t, ok)
  assert.Assert(t, err != nil)
  assert.Assert(t, foo.IsBar())
#+END_SRC

So far not anything extra-ordinary. Let's first look at some more /helper/ functions in the =assert= package and quickly
dive a bit deeper with =Comparison=.

**** More =assert= helpers

The additional helper functions are the following

- =Equal= uses the ==== operator to assert two values are equal.
- =DeepEqual= uses =google/go-cmp= to assert two values are equal (it's /close/ to =reflect.DeepEqual= but not
  quite). We'll detail a bit more the /options/ part of this function with =cmp.DeepEqual=.
- =Error= fails if the error is =nil= *or* the error message is not the expected one.
- =ErrorContains= fails if the error is =nil= *or* the error message does not contain the expected substring.
- =ErrorType= fails if the error is =nil= *or* the error type is not the expected type.
- =NilError= fails if the error is not =nil=.

All those helper functions have a equivalent function in the =cmp= package that returns a =Comparison=. I, personally,
prefer to use =assert.Check= or =assert.Assert= in combination with =cmp.Comparison= as it allows me to write all my
assertions the same way, with built-ins comparison or with my own — i.e. =assert.Assert(t, is.Equal(…), "message"= or
=assert.Assert(t, stackIsUp(c, time…), "another message")=.

**** =cmp.Comparison=

This is where it get really interesting, =gotest.tools= tries to make it as easy as possible for you to create
appropriate comparison — making you test readable as much as possible.

Let's look a bit at the =cmp.Comparison= type.

#+BEGIN_SRC go
type Comparison func() Result
#+END_SRC

It's just a function that returns a =cmp.Result=, so let's look at =cmp.Result= definition.

#+BEGIN_SRC go
type Result interface {
        Success() bool
}
#+END_SRC

Result is an =interface=, thus any /struct/ that provide a function =Success= that returns a =bool= can be used as a
comparison result, making it really easy to use in your code. There is also existing type of result to make it even
quicker to write your own comparison.

- =ResultSuccess= is a constant which is returned to indicate success.
- =ResultFailure= and =ResultFailureTemplate= return a failed Result with a failure message.
- =ResultFromError= returns =ResultSuccess= if =err= is nil. Otherwise =ResultFailure= is returned with the error
  message as the failure message. It works a bit like the =errors.Wrap= function of the [[https://github.com/pkg/errors][=github.com/pkgs/errors=]]
  package.

The =cmp= package comes with a few defined comparison that, we think, should cover a high number of use-cases. Let's
look at them.

***** Equality with =Equal= and =DeepEqual=

#+BEGIN_QUOTE
Equal uses the == operator to assert two values are equal and fails the test if they are not equal.

If the comparison fails Equal will use the variable names for x and y as part of the failure message to identify the
actual and expected values.

If either x or y are a multi-line string the failure message will include a unified diff of the two values. If the
values only differ by whitespace the unified diff will be augmented by replacing whitespace characters with visible
characters to identify the whitespace difference.
#+END_QUOTE

On the other hand…

#+BEGIN_QUOTE
DeepEqual uses google/go-cmp (http://bit.do/go-cmp) to assert two values are equal and fails the test if they are not
equal.

Package https://godoc.org/gotest.tools/assert/opt provides some additional commonly used Options.
#+END_QUOTE

Using one or the other is as simple as : if you wrote your =if= with ==== then use =Equal=, otherwise use =DeepEqual=.
=DeepEqual= (and usually =reflect.DeepEqual=) is used when you want to compare anything more complex than primitive
types. One advantage of using =cmp.DeepEqual= over =reflect.DeepEqual= (in an if), is that you get a well crafted
message that shows the diff between the expected and the actual structs compared – and you can pass options to it.

#+BEGIN_SRC go
assert.Assert(t, cmp.DeepEqual([]string{"a", "b"}, []string{"b", "a"}))
// Will print something like
// --- result
// +++ exp
// {[]string}[0]:
//         -: "a"
//         +: "b"
// {[]string}[1]:
//         -: "b"
//         +: "a"
foo := &someType(a: "with", b: "value")
bar := &someType(a: "with", b: "value")
// the following will succeed as foo and bar are _DeepEqual_
assert.Assert(t, cmp.DeepEqual(foo, bar))
#+END_SRC

When using =DeepEqual=, you may end up with really weird behavior(s). You may want to ignore some fields, or consider
=nil= slice or map the same as empty ones ; or more common, your /struct/ contains some unexported fields that you
cannot use when comparing (as they are not exported 😓). In those case, you can use =go-cmp= options.

Some existing one are :
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#EquateEmpty][=EquateEmpty=]] returns a Comparer option that determines all maps and slices with a length of zero to be equal,
 regardless of whether they are nil.
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#IgnoreFields][=IgnoreFields=]] returns an Option that ignores exported fields of the given names on a single struct type. The struct
  type is specified by passing in a value of that type.
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#IgnoreUnexported][=IgnoreUnexported=]] returns an Option that only ignores the immediate unexported fields of a struct, including anonymous
  fields of unexported types.
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#SortSlices][=SortSlices=]] returns a Transformer option that sorts all =[]V=
- … and [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts][more]] 👼

=gotest.tools= also defines some *and* you can define yours ! As an example, =gotest.tools= defines =TimeWithThreshold=
and =DurationWithThreshold= that allows to not fails if the time (or duration) is not exactly the same but in the
specified threshold we specified. Here is the code for =DurationWithThreshold= for inspiration.

#+BEGIN_SRC go
// DurationWithThreshold returns a gocmp.Comparer for comparing time.Duration. The
// Comparer returns true if the difference between the two Duration values is
// within the threshold and neither value is zero.
func DurationWithThreshold(threshold time.Duration) gocmp.Option {
        return gocmp.Comparer(cmpDuration(threshold))
}

func cmpDuration(threshold time.Duration) func(x, y time.Duration) bool {
        return func(x, y time.Duration) bool {
                if x == 0 || y == 0 {
                        return false
                }
                delta := x - y
                return delta <= threshold && delta >= -threshold
        }
}
#+END_SRC

Another good example for those options is when you want to skip some field. In [[https://github.com/docker/docker][=docker/docker=]] we want to be able to
easily check for equality between two service specs, but those might have different =CreatedAt= and =UpdatedAt= values
that we usually don't care about – what we want is to make sure it happens in the past 20 seconds. You can easily define
an option for that.

#+BEGIN_SRC go
  func cmpServiceOpts() cmp.Option {
          const threshold = 20 * time.Second

          // Apply withinThreshold only for the following fields
          metaTimeFields := func(path cmp.Path)bool {
                  switch path.String() {
                  case "Meta.CreatedAt", "Meta.UpdatedAt":
                          return true
                  }
                  return false
          }
          // have a 20s threshold for the time value that will be passed
          withinThreshold := cmp.Comparer(func(x, y time.Time) bool {
                  delta := x.Sub(y)
                  return delta < threshold && delta > -threshold
          })

          return cmp.FilterPath(metaTimeFields, withinThreshold)
  }
#+END_SRC

I recommend you look at the [[https://godoc.org/gotest.tools/assert/opt][gotest.tools/assert/opt]] documentation to see which one are defined and how to use them.

***** Errors with =Error=, =ErrorContains= and =ErrorType=

Checking for errors is *very common* in Go, having =Comparison= function for it was a requirement.

- =Error= fails if the error is =nil= *or* the error message is not the expected one.
- =ErrorContains= fails if the error is =nil= *or* the error message does not contain the expected substring.
- =ErrorType= fails if the error is =nil= *or* the error type is not the expected type.

Let's first look at the most used : =Error= and =ErrorContains=.

#+BEGIN_SRC go
  var err error
  // will fail with : expected an error, got nil
  assert.Check(t, cmp.Error(err, "message in a bottle"))
  err = errors.Wrap(errors.New("other"), "wrapped")
  // will fail with : expected error "other", got "wrapped: other"
  assert.Check(t, cmp.Error(err, "other"))
  // will succeed
  assert.Check(t, cmp.ErrorContains(err, "other"))
#+END_SRC

As you can see =ErrorContains= is especially useful when working with /wrapped/ errors.
Now let's look at =ErrorType=.

#+BEGIN_SRC go
  var err error
  // will fail with : error is nil, not StubError
  assert.Check(t, cmp.ErrorType(err, StubError{}))

  err := StubError{"foo"}
  // will succeed
  assert.Check(t, cmp.ErrorType(err, StubError{}))

  // Note that it also work with a function returning an error
  func foo() error {}
  assert.Check(t, cmp.ErrorType(foo, StubError{}))
#+END_SRC

***** Bonus with =Panics=

Sometimes, a code is supposed to /panic/, see [[https://golang.org/doc/effective_go.html#panic][Effective Go (#Panic)]] for more information. And thus, you may want to make
sure you're code panics in such cases. It's always a bit tricky to test a code that panic as you have to use a deferred
function to recover the panic — but then if the panic doesn't happen how do you fail the test ?

This is where =Panics= comes handy.

#+BEGIN_SRC go
  func foo(shouldPanic bool) {
          if shouldPanic {
                  panic("booooooooooh")
          }
          // don't worry, be happy
  }
  // will fail with : did not panic
  assert.Check(t, cmp.Panics(foo(false)))
  // will succeed
  assert.Check(t, cmp.Panics(foo(true)))
#+END_SRC

***** Miscellaneous with =Contains=, =Len= and =Nil=

Those last three /built-in/ =Comparison= are pretty straightforward.

- =Contains= succeeds if item is in collection. Collection may be a string, map, slice, or array.

  If collection is a string, item must also be a string, and is compared using =strings.Contains()=. If collection is a
  Map, contains will succeed if item is a key in the map. If collection is a slice or array, item is compared to each
  item in the sequence using ==reflect.DeepEqual()==.
- =Len= succeeds if the sequence has the expected length.
- =Nil= succeeds if obj is a nil interface, pointer, or function.

#+BEGIN_SRC go
  // Contains works on string, map, slice or arrays
  assert.Check(t, cmp.Contains("foobar", "foo"))
  assert.Check(t, cmp.Contains([]string{"a", "b", "c"}, "b"))
  assert.Check(t, cmp.Contains(map[string]int{"a": 1, "b": 2, "c": 4}, "b"))

  // Len also works on string, map, slice or arrays
  assert.Check(t, cmp.Len("foobar", 6))
  assert.Check(t, cmp.Len([]string{"a", "b", "c"}, 3))
  assert.Check(t, cmp.Len(map[string]int{"a": 1, "b": 2, "c": 4}, 3))

  // Nil
  var foo *MyStruc
  assert.Check(t, cmp.Nil(foo))
  assert.Check(t, cmp.Nil(bar()))
#+END_SRC

But let's not waste more time and let's see how to write our own =Comparison= !

***** Write your own =Comparison=

One of the main aspect of =gotest.tools/assert= is to make it easy for developer to write as less boilerplate code as
possible while writing tests. Writing your own =Comparison= allows you to write a well named function that will be easy
to read and that can be re-used across your tests.

Let's look back at the =cmp.Comparison= and =cmp.Result= types.

#+BEGIN_SRC go
type Comparison func() Result

type Result interface {
        Success() bool
}
#+END_SRC

A =Comparison= for =assert.Check= or =assert.Check= is a function that return a =Result=, it's pretty straightforward to
implement, especially with =cmp.ResultSuccess= and =cmp.ResultFailure(…)= (as seen previously).

#+BEGIN_SRC go
  func regexPattern(value string, pattern string) cmp.Comparison {
          return func() cmp.Result {
                  re := regexp.MustCompile(pattern)
                  if re.MatchString(value) {
                          return cmp.ResultSuccess
                  }
                  return cmp.ResultFailure(
                          fmt.Sprintf("%q did not match pattern %q", value, pattern))
          }
  }

  // To use it
  assert.Check(t, regexPattern("12345.34", `\d+.\d\d`))
#+END_SRC

As you can see, it's pretty easy to implement, and you can do quite a lot in there easily. If a function call returns an
error inside of your =Comparison= function, you can use =cmp.ResultFromError= for example. Having something like
=assert.Check(t, isMyServerUp(":8080"))= is way more readable than a 30-line of code to check it.

**** Conclusion…

… and that's a wrap. We only looked at the =assert= package of [[https://gotest.tools][=gotest.tools=]] so far, but it's already quite a bit to process.

We've seen :
- the main functions provided by this package : =assert.Assert= and =assert.Check=
- some helper functions like =assert.NilError=, …
- the =assert/cmp=, and =assert/opt= sub-package that allows you to write more custom =Comparison=

Next time, we'll look at the =skip= package, that is a really simple wrapper on top of =testing.Skip= function.

*** Golang testing — gotest.tools skip                               :skip:
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-09-01-gotest-tools-skip
:EXPORT_DATE: 2018-09-01
:END:

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =skip= package. This is a
really simple one so this should be quick.

#+BEGIN_QUOTE
=skip= provides functions for skipping a test and printing the source code of the
condition used to skip the test.
#+END_QUOTE

The package consists of only one function : =If=. The idea comes mainly from
[[https://github.com/docker/docker][=docker/docker=]] integration test suite, where we wanted to skip some test (or test suites)
given different context. By context I mean things like the system we are running on
(=Windows=, =Linux=, …) or the capabilities of the running kernel or node (is =apparmor=
available or not on the current machine).

This =If= method takes a =testing.T= pointer and either a boolean, a function that
returns a boolean, *or* an expression.

#+BEGIN_SRC go
  // boolean
  //   --- SKIP: TestName (0.00s)
  //           skip.go:19: MissingFeature
  var MissingFeature bool
  skip.If(t, MissingFeature)

  // function
  //   --- SKIP: TestName (0.00s)
  //           skip.go:19: !IsExperimentalDaemon(dockerClient): daemon is not experimental
  skip.If(t, IsExperimentalDaemon(dockerClient), "daemon is not experimental")

  // expression
  //   --- SKIP: TestName (0.00s)
  //           skip.go:19: apiVersion < version("v1.24")
  skip.If(t, apiVersion < version("v1.24"))
#+END_SRC

There is few elements to note though :

- This package (as other parts of the =gotest.tools= packages), will try to look at source
  files to display the expression used (same goes for =assert=). This is usually not a
  problem because you run tests where the source code is. *However*, in the cases you
  generate a test binary to be executed later (à-la =kubernetes= or other projects), this
  can display a weird error message if the sources are not available… You shouldn't be
  worried too much about it, but it's better if you know :)
- The main reason to use =skip.If= is mainly for new contributors to get in quickly,
  *reducing potential friction of them running the tests on their environment*. The more
  the tests are written in a way they explicitely declare their requirements (and skipped
  if the environment does not meet those), the easier it makes contributors run your
  tests. *But*, this also means, you should try to measure the skipped tests on your
  continuous integration system to make sure you run all of them eventually… otherwise
  it's dead code. /But more on that in later posts 😉/.

That's all for today folks, told you that was going to be quick.
*** Golang testing — gotest.tools golden                           :golden:
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-09-06-gotest-tools-golden
:EXPORT_DATE: 2018-09-06
:END:

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =golden= package. This is a
[[/posts/2017-04-22-golang-testing-golden-file/][/quick follow-up/ on a previous =golden= post]], but focused on the =gotest.tools=
implementation. I'm gonna be quicker, please read that one if =golden= files is a new
concept for you.

#+BEGIN_QUOTE
Package =golden= provides tools for comparing large mutli-line strings.

Golden files are files in the =./testdata/= sub-directory of the package under test.
#+END_QUOTE

In the previous article, we described the problem, and how to fix it by writing a small
helper. Well, that small helper is in =gotest.tools/golden= now, and it has a tiny bit
more features.

One of the difference between the =gotest.tools= implementation and the previous post is
the flag name. In =gotest.tools/golden=, the flag is =-test.update-golden= (was just
=-test.update= before). Just as before, if the =-test.update-golden= flag is set then the
actual content is written to the golden file, before reading it and comparing.

There is two ways to use the =golden= package:
- on it's own, using =golden.Assert= or =golden.AssertBytes=
- as a =cmp.Comparison=, with =golden.String= or =golden.Bytes=

**** =Assert= and =AssertBytes=

Using =Assert= functions should be straightforward. Both =Assert= function compares the
actual content to the expected content in the golden file and returns whether the
assertion was successful (true) or not (false).

- =Assert= uses string. Note that this one *removes carriage return* before comparing to
  depend as less as possible of the system (=\n= vs =\r\n= 😅)
- =AssertBytes= uses raw data (in the form of =[]byte=)

#+BEGIN_SRC go
  golden.Assert(t, "foo", "foo-content.golden")
  // Could also be used to check some binary format
  golden.AssertBytes(t, []byte("foo"), "foo-content.golden")
#+END_SRC

**** =Bytes= and =String=

As written in a [[/posts/2018-08-16-gotest-tools-assertions/][previous post (about the =assert= package)]], I prefer to use =cmp.Comparison=.

#+BEGIN_QUOTE
All those helper functions have a equivalent function in the =cmp= package that returns a
=Comparison=. I, personally, prefer to use =assert.Check= or =assert.Assert= in
combination with =cmp.Comparison= as it allows me to write all my assertions the same way,
with built-ins comparison or with my own — i.e. =assert.Assert(t, is.Equal(…), "message"=
or =assert.Assert(t, stackIsUp(c, time…), "another message")=.
#+END_QUOTE

The =golden= package gives us that too, in the form of =Bytes= and =String=. Using the
=assert.Check= or =assert.Assert= functions with those is equivalent to their /helper/
counter-part =golden.Assert= and =golden.AssertBytes=.

#+BEGIN_SRC go
  assert.Assert(t, golden.String("foo", "foo-content.golden"))
  // Could also be used to check some binary format
  assert.Assert(t, golden.Bytes([]byte("foo"), "foo-content.golden"))
#+END_SRC

**** Conclusion…

… that's a wrap. As for [[/posts/2018-09-01-gotest-tools-skip/][=skip=]], this is a small package, so the post was going to be
quick. =golden= package just solve a specific problem (read [[/posts/2017--04-22-golang-testing-golden-file/][Golang testing — golden file]])
in a simple way.

*** Golang testing — gotest.tools fs                           :filesystem:
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-09-14-gotest-tools-fs
:EXPORT_DATE: 2018-09-14
:END:

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =fs= package.

#+BEGIN_QUOTE
Package fs provides tools for creating temporary files, and testing the contents and structure of a directory.
#+END_QUOTE

This package is heavily using functional arguments (as we saw in [[/posts/2017-01-01-go-testing-functionnal-builders/][functional arguments for
wonderful builders]]). Functional arguments is, in a nutshell, a combinaison of two Go
features : /variadic/ functions (=...= operation in a function signature) and the fact
that =func= are /first class citizen/. This looks more or less like that.

#+BEGIN_SRC go
  type Config struct {}

  func MyFn(ops ...func(*Config)) *Config {
          c := &Config{} // with default values
          for _, op := range ops {
                  op(c)
          }
          return c
  }

  // Calling it
  conf := MyFn(withFoo, withBar("baz"))
#+END_SRC

The =fs= package has too *main* purpose :

1. create folders and files required for testing in a simple manner
2. compare two folders structure (and content)

**** Create folder structures

Sometimes, you need to create folder structures (and files) in tests. Doing =i/o= work
takes time so try to limit the number of tests that needs to do that, especially in unit
tests. Doing it in tests adds a bit of boilerplate that could be avoid. As stated [[/posts/2017-01-01-go-testing-functionnal-builders/][before]] :

#+BEGIN_QUOTE
One of the most important characteristic of a unit test (and any type of test really) is
*readability*. This means it should be easy to read but most importantly it should *clearly
show the intent* of the test. The setup (and cleanup) of the tests should be as small as
possible to avoid the noise.
#+END_QUOTE

In a test you usually end up using =ioutil= function to create what you need. This looks
somewhat like the following.

#+BEGIN_SRC go
  path, err := ioutil.TempDir("", "bar")
  if err != nil { // or using `assert.Assert`
          t.Fatal(err)
  }
  if err := os.Mkdir(filepath.Join(path, "foo"), os.FileMode(0755)); err != nil {
          t.Fatal(err)
  }
  if err := ioutil.WriteFile(filepath.Join(path, "foo", "bar"), []byte("content"), os.FileMode(0777)); err != nil {
          t.Fatal(err)
  }
  defer os.RemoveAll(path) // to clean up at the end of the test
#+END_SRC

The =fs= package intends to help reduce the noise and comes with a bunch function to create
folder structure :

- two main function =NewFile= and =NewDir=
- a bunch of /operators/ : =WithFile=, =WithDir=, …

#+BEGIN_SRC go
  func NewDir(t assert.TestingT, prefix string, ops ...PathOp) *Dir {
          // …
  }

  func NewFile(t assert.TestingT, prefix string, ops ...PathOp) *File {
          // …
  }
#+END_SRC

The =With*= function are all satisfying the =PathOp= interface, making =NewFile= and
=NewDir= extremely composable. Let's first see how our above example would look like using
the =fs= package, and then, we'll look a bit more at the main =PathOp= function…

#+BEGIN_SRC go
  dir := fs.NewDir(t, "bar", fs.WithDir("foo",
          fs.WithFile("bar", fs.WithContent("content"), fs.WithMode(os.FileMode(0777))),
  ))
  defer dir.Remove()
#+END_SRC

It's clean and simple to read. The intent is well described and there is not that much of
noise. =fs= functions tends to have /sane/ and /safe/ defaults value (for =os.FileMode=
for example). Let's list the main, useful, =PathOp= provided by =gotest.tools/fs=.

- =WithDir= creates a sub-directory in the directory at path.
- =WithFile= creates a file in the directory at path with content.
- =WithSymlink= creates a symlink in the directory which links to target. Target must be a
  path relative to the directory.
- =WithHardlink= creates a link in the directory which links to target. Target must be a
  path relative to the directory.
- =WithContent= and =WWithBytes= write content to a file at Path (from a =string= or a
  =[]byte= slice).
- =WithMode= sets the file mode on the directory or file at path.
- =WithTimestamps= sets the access and modification times of the file system object at
  path.
- =FromDir= copies the directory tree from the source path into the new Dir. This is
  pretty useful when you have a huge folder structure already present in you =testdata=
  folder or elsewhere.
- =AsUser= changes ownership of the file system object at Path.

Also, note that =PathOp= being an function type, you can provide your own implementation
for specific use-cases. Your function just has to satisfy =PathOp= signature.

#+BEGIN_SRC go
  type PathOp func(path Path) error
#+END_SRC

**** Compare folder structures

Sometimes, the code you're testing is creating a folder structure, and you would like to
be able to tests that, with the given arguments, it creates the specified structure. =fs=
allows you to do that too.

The package provides a =Equal= function, which returns a =Comparison=, that the [[/posts/2018-08-16-gotest-tools-assertions/][=assert=]]
package understand. It works by comparing a =Manifest= type provided by the test and a
=Manifest= representation of the specified folder.

#+BEGIN_QUOTE
 Equal compares a directory to the expected structured described by a manifest and returns
 success if they match. If they do not match the failure message will contain all the
 differences between the directory structure and the expected structure defined by the
 Manifest.
#+END_QUOTE

A =Manifest= stores the expected structure and properties of files and directories in a
file-system. You can create a =Manifest= using either the functions =Expected= or
=ManifestFromDir=.

We're going to focus on the =Expected= function, as =ManifestFromDir= does pretty much
what you would expected : it takes the specified path, and returns a =Manifest= that
represent this folder.

#+BEGIN_SRC go
  func Expected(t assert.TestingT, ops ...PathOp) Manifest
#+END_SRC

=Expected= is close to =NewDir= function : it takes the same =PathOp= functional
arguments. This makes creating a =Manifest= straightforward, as it's working the same. Any
function that satisfy =PathOp= can be used for =Manifest= the exact same way you're using
them on =fs.NewDir=.

There is a few additional functions that are only useful with =Manifest= :

- =MatchAnyFileContent= updates a Manifest so that the file at path may contain any content.
- =MatchAnyFileMode= updates a Manifest so that the resource at path will match any file mode.
- =MatchContentIgnoreCarriageReturn= ignores cariage return discrepancies.
- =MatchExtraFiles= updates a Manifest to allow a directory to contain unspecified files.

#+BEGIN_SRC go
  path := operationWhichCreatesFiles()
  expected := fs.Expected(t,
      fs.WithFile("one", "",
          fs.WithBytes(golden.Get(t, "one.golden")),
          fs.WithMode(0600)),
      fs.WithDir("data",
              fs.WithFile("config", "", fs.MatchAnyFileContent)),
  )

  assert.Assert(t, fs.Equal(path, expected))
#+END_SRC

The following example compares the result of =operationWhichCreatesFiles= to the expected
=Manifest=. As you can see it also integrates well with other part of the =gotest.tools=
library, with the [[/posts/2018-09-06-gotest-tools-golden/][=golden= package]] in this example.

**** Conclusion…

… that's a wrap. In my opinion, this is one the most useful package provided by
=gotest.tools= after =assert=. It allows to create simple or complex folder structure
without the noise that usually comes with it.

*** Golang testing — gotest.tools icmd                       :exec:command:
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-09-18-gotest-tools-icmd
:EXPORT_DATE: 2018-09-18
:END:

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =icmd= package.

#+BEGIN_QUOTE
Package icmd executes binaries and provides convenient assertions for testing the results.
#+END_QUOTE

After file-system operations (seen in [[/posts/2018-09-14-gotest-tools-fs/][=fs=]]), another common use-case in tests is to
*execute a command*. The reasons can be you're testing the =cli= you're currently writing
or you need to setup something using a command line. A classic execution in a test might
lookup like the following.

#+BEGIN_SRC go
  cmd := exec.Command("echo", "foo")
  cmd.Stout = &stdout
  cmd.Env = env
  if err := cmd.Run(); err != nil {
          t.Fatal(err)
  }
  if string(stdout) != "foo" {
          t.Fatalf("expected: foo, got %s", string(stdout))
  }
#+END_SRC

The package =icmd= is there to ease your pain (as usual 😉) — we used /the name =icmd=/
instead of =cmd= because it's a pretty common identifier in Go source code, thus would be
really easy to /shadow/ — and have some really weird problems going on.

The usual =icmd= workflow is the following:

1. Describe the command you want to execute using : type =Cmd=, function =Command= and
   =CmdOp= operators.
2. Run it using : function =RunCmd= or =RunCommand= (that does 1. for you). You can also
   use =StartCmd= and =WaitOnCmd= if you want more control on the execution workflow.
3. Check the result using the =Assert=, =Equal= or =Compare= methods attached to the
   =Result= struct that the command execution return.

**** Create and run a command

Let's first dig how to create commands. In this part, the assumption here is that the
command is successful, so we'll have =.Assert(t, icmd.Success)= for now — we'll learn more
about =Assert= in the next section 👼.

The simplest way to create and run a command is using =RunCommand=, it has the same
signature as =os/exec.Command=. A simple command execution goes as below.

#+BEGIN_SRC go
  icmd.RunCommand("echo", "foo").Assert(t, icmd.Sucess)
#+END_SRC

Sometimes, you need to customize the command a bit more, like adding some environment
variable. In those case, you are going to use =RunCmd=, it takes a =Cmd= and operators.
Let's look at those functions.

#+BEGIN_SRC go
  func RunCmd(cmd Cmd, cmdOperators ...CmdOp) *Result

  func Command(command string, args ...string) Cmd

  type Cmd struct {
          Command []string
          Timeout time.Duration
          Stdin   io.Reader
          Stdout  io.Writer
          Dir     string
          Env     []string
  }
#+END_SRC

As we've seen [[/posts/2017-01-01-go-testing-functionnal-builders/][multiple]] [[/posts/2018-08-16-gotest-tools-assertions/][times]] [[/posts/2018-09-14-gotest-tools-fs/][before]], it uses the /powerful/ functional arguments. At the
time I wrote this post, the =icmd= package doesn't contains too much =CmdOp= [fn:1], so I'll
propose two version for each example : one with =CmdOpt= present in [[https://github.com/gotestyourself/gotest.tools/pull/122][this PR]] and one
without them.

#+BEGIN_SRC go
  // With
  icmd.RunCmd(icmd.Command("sh", "-c", "echo $FOO"),
          icmd.WithEnv("FOO=bar", "BAR=baz"), icmd.Dir("/tmp"),
          icmd.WithTimeout(10*time.Second),
  ).Assert(t, icmd.Success)

  // Without
  icmd.RunCmd(icmd.Cmd{
          Command: []string{"sh", "-c", "echo $FOO"},
          Env: []string{"FOO=bar", "BAR=baz"},
          Dir: "/tmp",
          Timeout: 10*time.Second,
  }).Assert(t, icmd.Success)
#+END_SRC

As usual, the intent is clear, it's simple to read and composable (with =CmdOp='s).

[fn:1] The =icmd= package is one of the oldest =gotest.tools= package, that comes from the
[[https://github.com/docker/docker][=docker/docker=]] initially. We introduced these =CmdOp= but implementations were in
=docker/docker= at first and we never really updated them.

**** Assertions

Let's dig into the assertion part of =icmd=. Running a command returns a struct
=Result=. It has the following methods :

- =Assert= compares the Result against the Expected struct, and fails the test if any of
  the expectations are not met.
- =Compare= compares the result to Expected and return an error if they do not match.
- =Equal= compares the result to Expected. If the result doesn't match expected
  returns a formatted failure message with the command, stdout, stderr, exit code, and any
  failed expectations. It returns an =assert.Comparison= struct, that can be used by other
  =gotest.tools=.
- =Combined= returns the stdout and stderr combined into a single string.
- =Stderr= returns the stderr of the process as a string.
- =Stdout= returns the stdout of the process as a string.

When you have a result, you, most likely want to do two things :

- /assert/ that the command succeed or failed with some specific values (exit code,
  stderr, stdout)
- use the output — most likely =stdout= but maybe =stderr= — in the rest of the test.

As seen above, /asserting/ the command result is using the =Expected= struct.

#+BEGIN_SRC go
  type Expected struct {
          ExitCode int    // the exit code the command returned
          Timeout  bool   // did it timeout ?
          Error    string // error returned by the execution (os/exe)
          Out      string // content of stdout
          Err      string // content of stderr
  }
#+END_SRC

=Success= is a constant that defines a success — it's an exit code of =0=, didn't timeout,
no error. There is also the =None= constant, that should be used for =Out= or =Err=, to
specify that we don't want any content for those standard outputs.

#+BEGIN_SRC go
  icmd.RunCmd(icmd.Command("cat", "/does/not/exist")).Assert(t, icmd.Expected{
          ExitCode: 1,
          Err:      "cat: /does/not/exist: No such file or directory",
  })

  // In case of success, we may want to do something with the result
  result := icmd.RunCommand("cat", "/does/exist")
  result.Assert(t, icmd.Success)
  // Read the output line by line
  scanner := bufio.NewScanner(strings.NewReader(result.Stdout()))
  for scanner.Scan() {
          // Do something with it
  }
#+END_SRC

If the =Result= doesn't map the =Expected=, a test failure will happen with a useful
message that will contains the executed command and what differs between the result and
the expectation.

#+BEGIN_SRC go
  result := icmd.RunCommand(…)
  result.Assert(t, icmd.Expected{
                  ExitCode: 101,
                  Out:      "Something else",
                  Err:      None,
  })
  // Command:  binary arg1
  // ExitCode: 99 (timeout)
  // Error:    exit code 99
  // Stdout:   the output
  // Stderr:   the stderr
  //
  // Failures:
  // ExitCode was 99 expected 101
  // Expected command to finish, but it hit the timeout
  // Expected stdout to contain "Something else"
  // Expected stderr to contain "[NOTHING]"
  …
#+END_SRC

Finally, we listed =Equal= above, that returns a =Comparison= struct. This means we can
use it easily with the =assert= package. As written in a [[/posts/2018-08-16-gotest-tools-assertions/][previous post (about the =assert=
package)]], I tend prefer to use =cmp.Comparison=. Let's convert the above examples using
=assert=.

#+BEGIN_SRC go
  result := icmd.RunCmd(icmd.Command("cat", "/does/not/exist"))
  assert.Check(t, result.Equal(icmd.Expected{
          ExitCode: 1,
          Err:      "cat: /does/not/exist: No such file or directory",
  }))

  // In case of success, we may want to do something with the result
  result := icmd.RunCommand("cat", "/does/exist")
  assert.Assert(t, result.Equal(icmd.Success))
  // Read the output line by line
  scanner := bufio.NewScanner(strings.NewReader(result.Stdout()))
  for scanner.Scan() {
          // Do something with it
  }
#+END_SRC

**** Conclusion…

… that's a wrap. The =icmd= package allows to easily run command and describe what result
are expected of the execution, with the least noise possible. We *use this package heavily*
on several =docker/*= projects (the engine, the cli)…

*** TODO Golang testing — gotest.tools poll                          :poll:
:PROPERTIES:
:EXPORT_FILE_NAME: 2019-03-24-gotest-tools-poll
:EXPORT_DATE: 2019-03-24
:END:

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =poll= package.

#+BEGIN_QUOTE
Package poll provides tools for testing asynchronous code.
#+END_QUOTE

When you write test, you may test a piece of code that work asynchronously, where the
state you're expecting is gonna take a bit of time to be achieved. This is especially true
when you work on networking or file-system code. And this happens a lot when you write
integration (or end-to-end) test, less for unit-tests.

The package =poll= is trying to tackle those use cases. We'll first take a look at the
main function, =WaitOn=, then how to write a ~Check~, using the ~Result~ type.

**** ~WaitOn~

Let's look into the main ~poll~ function : `WaitOn`.

#+begin_quote
 WaitOn a condition or until a timeout. Poll by calling check and exit when check returns
 a done Result. To fail a test and exit polling with an error return a error result.
#+end_quote

In a gist, ~WaitOn~ will run a /condition/ function until it either times out or
succeed. It wait for a given time/delay between each run.

#+begin_src go
  func WaitOn(t TestingT, check Check, pollOps ...SettingOp) {
          // […]
  }
#+end_src

As any /testing helper/ function, the first argument is ~*testing.T~ (or, in this case,
any thing that look like it, thanks to the ~TestingT~ interace). The two other arguments
are way more interesting :

- The ~Check~ is the condition that will run multiple times until it either timeout, or succeed.
- The ~SettingOp(s)~ which are options to configure the function, things like the timeout,
  or the /delay/ between each run.

The settings are pretty straightforward :

- ~WithDelay~ : sets the delay to wait between polls. The default delay is 100ms.
- ~WithTimeout~ : sets the timeout. The default timeout is 10s.

There is existing ~Check~ for common case:

- ~Connection~ : try to open a connection to the address on the named network.

  #+begin_src go
    poll.WaitOn(t, poll.Connection("tcp", "foo.bar:55555"), poll.WithTimeout("5s"))
  #+end_src

- ~FileExists~ : looks on filesystem and check that path exists.

  #+begin_src go
    poll.WaitOn(t, poll.FileExists("/should/be/created"), poll.WithDelay("1s"))
  #+end_src


**** ~Check~ and ~Result~

~Connection~ and ~FileExists~ are the only two /built-in/ ~Check~ provided by
~gotest.tools~. They are useful, but as usual, where ~gotest.tools~ shines is
extensiblity. It is really easy to define your own ~Check~.

#+begin_src go
  type Check func(t LogT) Result
#+end_src

A ~Check~ is, thus, only a function that takes ~LogT~ — which is anything that can log
something, like ~*testing.T~ — and return a ~Result~. Let's look at this intersting
~Result~ type.

#+begin_src go
  type Result interface {
      // Error indicates that the check failed and polling should stop, and the
      // the has failed
      Error() error
      // Done indicates that polling should stop, and the test should proceed
      Done() bool
      // Message provides the most recent state when polling has not completed
      Message() string
  }
#+end_src

Although it's an interface, the ~poll~ package defines built-in ~Result~ so that it's easy
to write ~Check~ without having to define you ~Result~ type.

- ~Continue~ returns a Result that indicates to WaitOn that it should continue
  polling. The message text will be used as the failure message if the timeout is reached.
- ~Success~ returns a Result where Done() returns true, which indicates to WaitOn that it
  should stop polling and exit without an error.
- ~Error~ returns a Result that indicates to WaitOn that it should fail the test and stop
  polling.

The basic just to write a ~Check~ is then :

- if the state is not there yet, return ~Continue~,
- if there is an error, unrelated to validating the state, return an ~Error~,
- if the state is there, return ~Success~.

Let's look at an example taken from the ~moby/moby~ source code.

#+begin_src go
  poll.WaitOn(t, container.IsInState(ctx, client, cID, "running"), poll.WithDelay(100*time.Millisecond))

  func IsInState(ctx context.Context, client client.APIClient, containerID string, state ...string) func(log poll.LogT) poll.Result {
          return func(log poll.LogT) poll.Result {
                  inspect, err := client.ContainerInspect(ctx, containerID)
                  if err != nil {
                          return poll.Error(err)
                  }
                  for _, v := range state {
                          if inspect.State.Status == v {
                                  return poll.Success()
                          }
                  }
                  return poll.Continue("waiting for container to be one of (%s), currently %s", strings.Join(state, ", "), inspect.State.Status)
          }
  }
#+end_src


**** TODO Conclusion

*** TODO Golang testing — gotest.tools x/subtest
*** TODO gotestsum
https://github.com/gotestyourself/gotestsum
*** TODO gauge for readme-test-driven
*** TODO continuous testing with filewatcher, goconvey, …
** Nix                                                               :nixos:
*** =nix run= aliases              :fish:alias:nix:shell:nix:home:manager:
:PROPERTIES:
:EXPORT_FILE_NAME: 2019-01-26-nix-run-alias
:EXPORT_DATE: 2019-01-26
:END:

I use [[https://nixos.org/][=NixOS=]] each and every day, everywhere. One really cool feature of =nix= is
=nix-shell= and more recently (with =nix= >= =2.0.0=), =nix run=.

#+begin_src man
Usage: nix run <FLAGS>... <INSTALLABLES>...

Summary: run a shell in which the specified packages are available.

Flags:
      --arg <NAME> <EXPR>         argument to be passed to Nix functions
      --argstr <NAME> <STRING>    string-valued argument to be passed to Nix functions
  -c, --command <COMMAND> <ARGS>  command and arguments to be executed; defaults to 'bash'
  -f, --file <FILE>               evaluate FILE rather than the default
  -i, --ignore-environment        clear the entire environment (except those specified with --keep)
  -I, --include <PATH>            add a path to the list of locations used to look up <...> file names
  -k, --keep <NAME>               keep specified environment variable
  -u, --unset <NAME>              unset specified environment variable

Examples:

  To start a shell providing GNU Hello from NixOS 17.03:
  $ nix run -f channel:nixos-17.03 hello

  To start a shell providing youtube-dl from your 'nixpkgs' channel:
  $ nix run nixpkgs.youtube-dl

  To run GNU Hello:
  $ nix run nixpkgs.hello -c hello --greeting 'Hi everybody!'

  To run GNU Hello in a chroot store:
  $ nix run --store ~/my-nix nixpkgs.hello -c hello

Note: this program is EXPERIMENTAL and subject to change.
#+end_src

As you can see from the =-h= summary, it makes it really easy to run a shell or a command
with some packages that are not in your main configuration. It will download the
package(s) if there are not available in the Nix store (=/nix/store/=).

A few month ago I decided it would be a perfect use-case for command I do not run
often. My idea was, let's define =aliases= (in the shell) that would make a simple command
call, like =ncdu=, become =nix run nixpkgs.ncdu -c ndcu=. My /shell of choice/ is [[https://fishshell.com/][fish]], so
I decided to dig into the /language/ in order to implement that.

The use case is the following :
- When I type =foo=, I want the command =foo= in package =bar= to be executed.
- I want to be able to pin a channel for the package — I'm using [[https://matthewbauer.us/][Matthew Bauer]] [[https://matthewbauer.us/blog/channel-changing.html][Channel
  Changing with Nix]] setup for pin-pointing a given channel.

**** Fish aliases experimentation

I had a feeling the built-in =alias= would not work so I ended up trying to define a
/dynamic/ function that would be the name of the command. That's the beauty of the shell,
everything is a command, even function appears as commands. If you define a function
=foo()=, you will be able to run =foo= in your shell, *and* it will take precedence over
the =foo= executable file that would be in your =PATH=.

I ended up with two main helper function that would create those /alias/ function.

#+begin_src fish
  function _nix_run_package
      set -l s $argv[1]
      set -l package (string split ":" $s)
      switch (count $package)
          case 1
              _nix_run $s $s $argv[2] $argv[3]
          case 2
              _nix_run $package[1] $package[2] $argv[2] $argv[3]
      end
  end

  function _nix_run
      set -l c $argv[1]
      set -l p $argv[2]
      set -l channel $argv[3]
      set -l channelsfile $argv[4]
      function $c --inherit-variable c --inherit-variable p --inherit-variable channel --inherit-variable channelsfile
          set -l cmd nix run
          if test -n "$channelsfile"
              set cmd $cmd -f $channelsfile
          end
          eval $cmd $channel.$p -c $c $argv
      end
  end
#+end_src

In a nutshell, =_nix_run= is the function that create the alias function. There is so
condition in there depending on whether we gave it a channel or not. So, a call like
=_nix_run foo bar unstable channels.nix= would, in the end generate a function =foo= with
the following call : =nix run -f channels.nix unstable.bar -c foo=.

The other function, =_nix_run_package= is there to make me write less when I define those
aliases — aka if the command and the package share the same name, I don't want to write it
twice. So, a call like =_nix_run_package foo nixpkgs= would result in a =_nix_run foo foo
nixpkgs=, whereas a call like =_nix_run_package foo:bar unstable channels.nix= would
result in a =_nix_run foo bar unstable channels.nix=.

An example is gonna be better than the above paragraphs. This is what I used to have in my
fish configuration.

#+begin_src fish
  function _def_nix_run_aliases
      set -l stable mr sshfs ncdu wakeonlan:python36Packages.wakeonlan lspci:pciutils lsusb:usbutils beet:beets gotop virt-manager:virtmanager pandoc nix-prefetch-git:nix-prefetch-scripts nix-prefetch-hg:nix-prefetch-scripts
      set -l unstable op:_1password update-desktop-database:desktop-file-utils lgogdownloader
      for s in $stable
          _nix_run_package $s nixpkgs
      end
      for s in $unstable
          _nix_run_package $s unstable ~/.config/nixpkgs/channels.nix
      end
  end
  # Call the function to create the aliases
  _def_nix_run_aliases
#+end_src

This works like a charm, and for a while, I was happy. But I soon realized something : I'm
not always on my shell — like, I tend to spend more and more time in =eshell=. This also
doesn't work with graphic tools like [[https://github.com/DaveDavenport/rofi][=rofi=]]. I needed actual command, so that external
tools would benefit from that. I ended up writing a small tool, [[https://github.com/vdemeester/nr][=nr=]] that integrates
nicely with =nix= and [[https://github.com/rycee/home-manager][=home-manager=]].

**** A proper tool : =nr=

The gist for this tool is simple :
- create an executable script that will call =nix run ...= instead of the command
- as for the above fish script, support different channels
- make sure we don't have conflicts — if the command already exists, then don't create the
  command

The =nr= tool would have to be able to manage multiple /profile/, which really stands for
multiple file. The main reason is really about how I manage my configuration ; To make it
simple, depending on the computer my configurations are setup, I may not have =go=, thus I
don't want any =go=-related aliases for a computer that doesn't have =go= (using =go= here
but you can replace with anything).

#+begin_src fish
$ nr default
> nr generate default
> virtmanager already exists
$ nr git
> nr generate git
#+end_src

=nr= generates a bash script that does the =nr run …= and mark it as executable. =nr=
needs to be able to clean files it has generated (in case we removed it from
aliases). Thus, I went for a really naive comment in the script. When generating a new set
of commands, =nr= will first remove previously generated script for this profile, and for
that, it uses the comment. Let's look at what a generated script looks like, for the
default profile.

#+begin_src bash
#!/usr/bin/env bash
# Generated by nr default
nix run nixpkgs.nix-prefetch-scripts -c nix-prefetch-git $@
#+end_src

The format used in =nr= is =json=. I'm not a /huge fan/ of =json= but it really was the
best format to use for this tool. The reason to use =json= are simple :

- Go has =encoding/json= built-in, so it's really easy to =Marshall= and =Unmarshall=
  structure.
  #+begin_src go
    type alias struct {
            Command string `json:"cmd"`
            Package string `json:"pkg"`
            Channel string `json:"chan"`
    }
  #+end_src
- Nix also has built-in support for =json= : =builtins.toJSON= will marshall a /struct/
  into a json file.

Finally, to avoid conflicts at /build time/ (=home-manager switch=) I couldn't use/define
a nix package, but to execute command(s) at the end of the build. One way to achieve it is
to use =file.?.onChange= script, which is executed after [[https://github.com/rycee/home-manager][=home-manager=]] has updated the
environment, *if* the file has changed. That means it's possible to check for executable
files in =~/.nix-profile/bin/= for defined aliases and create those that are not there,
with =nr=. My configuration then looks like the following.

#+BEGIN_SRC nix
  xdg.configFile."nr/default" = {
    text = builtins.toJSON [
      {cmd = "ncdu";} {cmd = "sshfs";} {cmd = "gotop";} {cmd = "pandoc";}
      {cmd = "wakeonlan"; pkg = "python36Packages.wakeonlan";}
      {cmd = "beet"; pkg = "beets";}
      {cmd = "virt-manager"; pkg = "virtmanager";}
      {cmd = "nix-prefetch-git"; pkg = "nix-prefetch-scripts";}
      {cmd = "nix-prefetch-hg"; pkg = "nix-prefetch-scripts";}
    ];
    onChange = "${pkgs.nur.repos.vdemeester.nr}/bin/nr default";
  };
#+END_SRC

And there you are, now, each time I update my environment (=home-manager switch=), =nr=
will regenerate my =nix run= aliases.

* Posts
** 2018 year review                                                 :review:
:PROPERTIES:
:EXPORT_FILE_NAME: 2019-01-20-2018-year-review.md
:EXPORT_DATE: 2019-01-20
:END:

Here is my review of 2018, the first of its kind, hopefully not the last 👼. I saw
some[fn:1] /2018[fn:2] reviews/[fn:3] articles[fn:4] in my Feedly feed and I thought it
would be a good idea to write my own too.

I'll try in the next year — maybe month if I ever want to do monthly reviews — to automate
some of it ; using the beloved =org-mode=.

[fn:1] [[https://punchagan.muse-amuse.in/blog/2018-in-review/][2018 in Review - Noetic Nought]]
[fn:2] [[https://medium.com/@buster/42-dig-deeper-e2278d1fe015][42 — Dig deeper – Buster Benson – Medium]]
[fn:3] [[https://jvns.ca/blog/2018/12/23/2018--year-in-review/][2018: Year in review - Julia Evans]]
[fn:4] [[https://writing.natwelch.com/post/685][Nat? Nat. Nat! | #685 2018 Year in Review]]

*** Work

The big change this year is : I changed job 👼. I went from Docker Inc. to Red Hat. I
needed a change and 5 month in, I think it was the *best choice I made in my life* so far
💃. I'm doing open-source for a living and best part, I am working remotely (more on that
later).

Before that, at Docker Inc., I continued the work I started years before,
a.k.a. maintaining the Moby project and the docker engine, among other Docker project
(both open-source and closed-source). I also helped the work on the compose side, from the
root of =docker/compose-on-kubernetes= (before it got open-sourced), to the =docker/app=
experiments.

At Red Hat, I started to work upstream in the Kubernetes community, mainly on the Knative
projects. I also work on the Openshift Cloud Function project (and thus team), and those
fellows are awesome ! Digging more into Openshift, and other part of the Red Hat portfolio
is a really good learning experience, and it's just the start !

As stated above, I am now working home, full-time. I could work from home from time to
time when I was at Docker inc, but working home full-time is another kind of beast. So far
it is really good, some adjustments were needed but it's for the best. Here is a small
take on "working from home":

- It's easy to have *no distraction*, thus having *really productive* piece of time
- It's also *really easy to work long day or really long period of time*. It's especially
  true if, like me, you work on a distributed team (across multiple timezones).
  - I ended up using the Pomodoro technique to make sure I move at least few times a day
  - I try to make sure I don't make an habits of checking out work code, email and other
    material after a certain hour in the evening. It's ok to do it sometimes, but for your
    sanity, you need some rest time.
- It's easy to adapt your day to circumstance. If you got to run errands in the middle of
  the day, it's no big deal. You can take the time back later on.
- It's so good to have *no* commmute time. That said I end up /walking or taking the bike/
  early morning to clear my head before work 😝.

*** Personal

Health wise, it's a mix of good and bad year. The first half was really good, the second
way less. End of august, I felt something weird in the right knee, and well, turns out my
internal meniscus is in a real bad shape. Just as before joining Docker, I'm gonna need a
surgery, on the right knee that time. It's gonna affect 2019 (the first half, I'm not
gonna be able to move around much but.. meh, it's life).

Now that I work from home, I'm really glad I got a standing desk at the end of 2017. I
tend to work standing most of the time -- except when my knee hurts (and most likely for
few months after the surgery 😅). I invested on a ultrawide screen, to get the same
experience I had at Docker. And oh boy those screens are good !

I also try to clean my desk and it's "neighboorhood". As I get older, I want less messy
stuuf (desk, flat, ...). I'm leaning towards having less stuff, being commputer related or
not. It's not minimalism, but it feel good to have less stuff, but stuff that you actually
use. I still have trouble throwing old computer away, mainly because I fell they can be
useful in some way.

[[/images/2019/01/desk1.jpg]]

This year I migrate all of my "infrastructure" computer to NixOS. I learned a lot of Nix,
reworked my configuration multiple time to end up with a [[https://github.com/vdemeester/nixos-configuration.git][system configuration repository]]
that uses modules, and a [[https://github.com/vdemeester/home.git][/home configuration repository/]] (for user configuration). The
[[https://github.com/vdemeester/home.git][home]] repository uses [[https://github.com/rycee/home-manager.git][=home-manager=]] and thus doesn't make any assumption of running on top
of NixOS. This allows me to have an /easy to get/ setup on any system that =nixpkgs=
supports (any Linux distribution, Mac OSX, Windows Subsystem Linux). The current
configuration is not yet optimal but I'm pretty happy about what I got :

- Custom DNS server @home to make it easier to target local hosts.
- Local proxies and mirrors for docker images, nixpkgs binary package and go modules to
  eat less bandwidth.
- Easy to setup VPN using [[https://www.wireguard.com/][WireGuard]].
- File replication using =syncthing= and automatic backup on my local NAS.
- Automatic system upgrade, thanks to NixOS. I'll probably write an article about that
  later on this year.

I started to use =todoist= in 2017, and boy, oh boy, it helped me quite a lot ! I'm using
it daily to organize my work and quickly get idea, and /todos/ out of my head. The main
problem with it is it's not integrated with another tool I'm using daily : Emacs and
=org-mode=. =org-mode= is a fantastic piece of software and is, on its own, the main
reason for me to invest time in Emacs. I'm taking note in =org-mode=, I write my daily
standup notes in there too. I end up going back and forth between =org-mode= and =todoist=
for those daily standup. I am lazy, I want to automate that. And the best way to do it, is
to also use =org-mode= for task management. I'm in a /transition/ mode right now, but my
goal for 2019 is to use todoist to take quick note/todo(s) on the move (aka on the phone)
and use =org-mode= for the rest.


*** Reading & Writing

I used to like reading, but the past years, I didn't really read that much, except some
technical books. 2018 in, that respect, is not an exception, I didn't read too much. Worse
than that, I started some book and stopped at some point, for no apparent reason ; and
now, I need to start back from the beginning, which, well, is not helping me want to read
them again.

I'm trying two thing to counter that and consume more books for the years to come.

1. I now have a reading list on my =org-mode= files, where I track which one I read and
   when I read them ; and maybe notes too. I have a lot of book on my kindle, that only
   wait for one thing, being read..
2. I subscribed to [[https://www.audible.fr][Audible]] 👼. Working from home, I tend to take a long break after lunch,
   where I'm going for a walk, for around an hour. I can't read while walking but I
   definitely can listen - that make audio books perfect for these moments. I also
   alternate between audio books and non-musical podcasts.

On the writing side, 2017 was a slow year in terms of writing (only 2 posts), 2018 was a
bit better, 6 posts -- it's a bit cheating, as it was mainly between changing jobs, and
on a series I still need to finish. I'm hoping to write more this year, hence the goals
I've set to myself below.

*** 2019 Goals

- *Get back on my feet after knee surgery (exercices, …)* 🏃
- *Read at least one book per month (be audible, ebook or paper)* 📖
- *Giving at least a talk (on Knative, containers, nixos, ..)* 🙊

  I didn't give too much talk in 2018 (at least less than 2017). I'm gonna try to get back
  at it this year. The surgery won't help but it's just few months.

- *At least 1 video per month* 📹

  I want to start recording some video, as I feel it's an easier medium than writing and,
  well, I wanna try !

- *At least 1 post per month* ✍️
- *Enhance my emacs skills (aka don't be afraid of the lisp)* ⌨️

  I'm using Emacs for almost anything that doesn't happen in a web browser. But I still
  feel like a newbie. I want to learn more, to write more lisp that help me being even
  more lazier (aka achieve more doing less 😝)

- *Enhance my Nix(OS) skills* 🐧
- *Learn / master a new language* 🎽

  I'm working with Go 90% of my time. I want to master and learn more language. On my list
  are Emacs Lisp, Rust, Typescript and Haskell.

