#+hugo_base_dir: ../
#+hugo_section: posts
#+seq_todo: TODO DRAFT NONE

#+options: creator:t

* Blog Ideas
** TODO Serie : Go exploration
*** TODO implicit interface
* Series
** Golang testing                             :@developement:testing:golang:
*** Golang testing â€” gotest.tools introduction
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-07-28-gotest-tools-intro
:EXPORT_DATE: 2018-07-28
:END:

I already wrote 2 previous posts about golang and testing. It's something I care deeply about and I wanted to continue
writing about it. It took me a bit more time than I thought, but getting back to it. Since the [[http://vincent.demeester.fr/posts/2017-04-22-golang-testing-golden-file/][last post]], Daniel Nephin
and I worked (but mainly Daniel ðŸ¤—) on bootstrapping a testing helper library.

Let me introduce it to you this library : [[https://gotest.tools][=gotest.tools=]]. As described in the [[https://godoc.org/gotest.tools][godoc]] package comment, =gotest.tools= is a
collection of packages to augment =testing= and support common patterns. It's an enhanced and growing version of the
initial helpers we (the docker/moby maintainers) wrote initially in [[https://github.com/docker/docker][=docker/docker=]] repository. We are using in quite some
project here at [[https://github.com][Docker]].

There is a bunch of packages that will all have their own post (linked here when available) :

- [[/posts/2018-08-16-gotest-tools-assertions/][=assert=]] (with =assert/cmp= and =assert/opt=) that provides assertions for comparing expected values to actual values.
- =env= that provides functions to test code that read environment variable or the current working directory.
- =fs= that provides tools for creating temporary files, and testing the contents and structure of a directory.
- =golden= that provides tools for comparing large multi-line strings.
- =icmd= that executes binaries and provides convenient assertions for testing the results.
- =poll= that provides tools for testing asynchronous code.
- [[/posts/2018-09-01-gotest-tools-skip/][=skip=]] that provides functions for skipping a test and printing the source code of the condition used to skip the test.

There is also experimental package, using the =x= notation (as the golang team uses, for example with =golang.org/x/sync=) :

- =x/subtest= that provides a =TestContext= to subtests which handles cleanup and provides a =testing.TB= and =context.Context=.

There is already some good =testing= helpers in the Go ecosystem : [[https://github.com/stretchr/testify][=testify=]], [[http://labix.org/gocheck][=gocheck=]], [[https://github.com/onsi/ginkgo][=ginkgo=]] and a lot more â€” so
why create a new one ? There is multiple reason for it, most of them can be seen in the following [[https://github.com/gotestyourself/gotest.tools/issues/49#issuecomment-362436026][GitHub issue]].

[[https://github.com/dnephin/][Daniel]] also wrote a very useful converter if your code base is currently using =testify= : =gty-migrate-from-testify=.

#+BEGIN_SRC sh
$ go get -u gotest.tools/assert/cmd/gty-migrate-from-testify
# [â€¦]
$ go list \
     -f '{{.ImportPath}} {{if .XTestGoFiles}}{{"\n"}}{{.ImportPath}}_test{{end}}' \
     ./... | xargs gty-migrate-from-testify
#+END_SRC

In the next post, let's dig into the assertion part of the library, package =assert= ðŸ‘¼.

*** Golang testing â€” gotest.tools assertions
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-08-16-gotest-tools-assertions
:EXPORT_DATE: 2018-08-16
:END:

Let's take a closer look at [[https://gotest.tools][=gotest.tools=]] assertions packages. This is mainly about =assert=, =assert/cmp= and
=assert/opt=.

#+BEGIN_QUOTE
Package assert provides assertions for comparing expected values to actual values. When assertion fails a helpful error
message is printed.
#+END_QUOTE

There is two main functions (=Assert= and =Check=) and some helpers (like =NilError=, â€¦). They all take a =*testing.T= as
a first argument, pretty common across testing Go libraries. Let's dive into those !

**** =Assert= and =Check=

Both those functions accept a =Comparison= (we'll check what it is later on) and fail the test when that comparison
fails. The one difference is that =Assert= will end the test execution at immediately whereas =Check= will fail the test
and proceed with the rest of the test case. This is similar to =FailNow= and =Fail= from the standard library
=testing=. Both have their use cases.

We'll Use =Assert= for the rest of the section but any example here would work with =Check= too. When we said
=Comparison= above, it's mainly the [[https://godoc.org/gotest.tools/assert#BoolOrComparison][BoolOrComparison]] interface â€” it can either be a boolean expression, or a
[[https://godoc.org/gotest.tools/assert/cmp#Comparison][cmp.Comparison]] type. =Assert= and =Check= code will be /smart/ enough to detect which one it is.

#+BEGIN_SRC go
assert.Assert(t, ok)
assert.Assert(t, err != nil)
assert.Assert(t, foo.IsBar())
#+END_SRC

So far not anything extra-ordinary. Let's first look at some more /helper/ functions in the =assert= package and quickly
dive a bit deeper with =Comparison=.

**** More =assert= helpers

The additional helper functions are the following

- =Equal= uses the ==== operator to assert two values are equal.
- =DeepEqual= uses =google/go-cmp= to assert two values are equal (it's /close/ to =reflect.DeepEqual= but not
  quite). We'll detail a bit more the /options/ part of this function with =cmp.DeepEqual=.
- =Error= fails if the error is =nil= *or* the error message is not the expected one.
- =ErrorContains= fails if the error is =nil= *or* the error message does not contain the expected substring.
- =ErrorType= fails if the error is =nil= *or* the error type is not the expected type.
- =NilError= fails if the error is not =nil=.

All those helper functions have a equivalent function in the =cmp= package that returns a =Comparison=. I, personally,
prefer to use =assert.Check= or =assert.Assert= in combination with =cmp.Comparison= as it allows me to write all my
assertions the same way, with built-ins comparison or with my own â€” i.e. =assert.Assert(t, is.Equal(â€¦), "message"= or
=assert.Assert(t, stackIsUp(c, timeâ€¦), "another message")=.

**** =cmp.Comparison=

This is where it get really interesting, =gotest.tools= tries to make it as easy as possible for you to create
appropriate comparison â€” making you test readable as much as possible.

Let's look a bit at the =cmp.Comparison= type.

#+BEGIN_SRC go
type Comparison func() Result
#+END_SRC

It's just a function that returns a =cmp.Result=, so let's look at =cmp.Result= definition.

#+BEGIN_SRC go
type Result interface {
        Success() bool
}
#+END_SRC

Result is an =interface=, thus any /struct/ that provide a function =Success= that returns a =bool= can be used as a
comparison result, making it really easy to use in your code. There is also existing type of result to make it even
quicker to write your own comparison.

- =ResultSuccess= is a constant which is returned to indicate success.
- =ResultFailure= and =ResultFailureTemplate= return a failed Result with a failure message.
- =ResultFromError= returns =ResultSuccess= if =err= is nil. Otherwise =ResultFailure= is returned with the error
  message as the failure message. It works a bit like the =errors.Wrap= function of the [[https://github.com/pkg/errors][=github.com/pkgs/errors=]]
  package.

The =cmp= package comes with a few defined comparison that, we think, should cover a high number of use-cases. Let's
look at them.

***** Equality with =Equal= and =DeepEqual=

#+BEGIN_QUOTE
Equal uses the == operator to assert two values are equal and fails the test if they are not equal.

If the comparison fails Equal will use the variable names for x and y as part of the failure message to identify the
actual and expected values.

If either x or y are a multi-line string the failure message will include a unified diff of the two values. If the
values only differ by whitespace the unified diff will be augmented by replacing whitespace characters with visible
characters to identify the whitespace difference.
#+END_QUOTE

On the other handâ€¦

#+BEGIN_QUOTE
DeepEqual uses google/go-cmp (http://bit.do/go-cmp) to assert two values are equal and fails the test if they are not
equal.

Package https://godoc.org/gotest.tools/assert/opt provides some additional commonly used Options.
#+END_QUOTE

Using one or the other is as simple as : if you wrote your =if= with ==== then use =Equal=, otherwise use =DeepEqual=.
=DeepEqual= (and usually =reflect.DeepEqual=) is used when you want to compare anything more complex than primitive
types. One advantage of using =cmp.DeepEqual= over =reflect.DeepEqual= (in an if), is that you get a well crafted
message that shows the diff between the expected and the actual structs compared â€“ and you can pass options to it.

#+BEGIN_SRC go
assert.Assert(t, cmp.DeepEqual([]string{"a", "b"}, []string{"b", "a"}))
// Will print something like
// --- result
// +++ exp
// {[]string}[0]:
//         -: "a"
//         +: "b"
// {[]string}[1]:
//         -: "b"
//         +: "a"
foo := &someType(a: "with", b: "value")
bar := &someType(a: "with", b: "value")
// the following will succeed as foo and bar are _DeepEqual_
assert.Assert(t, cmp.DeepEqual(foo, bar))
#+END_SRC

When using =DeepEqual=, you may end up with really weird behavior(s). You may want to ignore some fields, or consider
=nil= slice or map the same as empty ones ; or more common, your /struct/ contains some unexported fields that you
cannot use when comparing (as they are not exported ðŸ˜“). In those case, you can use =go-cmp= options.

Some existings one are :
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#EquateEmpty][=EquateEmpty=]] returns a Comparer option that determines all maps and slices with a length of zero to be equal,
 regardless of whether they are nil.
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#IgnoreFields][=IgnoreFields=]] returns an Option that ignores exported fields of the given names on a single struct type. The struct
  type is specified by passing in a value of that type.
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#IgnoreUnexported][=IgnoreUnexported=]] returns an Option that only ignores the immediate unexported fields of a struct, including anonymous
  fields of unexported types.
- [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts#SortSlices][=SortSlices=]] returns a Transformer option that sorts all =[]V=
- â€¦ and [[https://godoc.org/github.com/google/go-cmp/cmp/cmpopts][more]] ðŸ‘¼

=gotest.tools= also defines some *and* you can define yours ! As an example, =gotest.tools= defines =TimeWithThreshold=
and =DurationWithThreshold= that allows to not fails if the time (or duration) is not exactly the same but in the
specified threshold we specified. Here is the code for =DurationWithThreshold= for inspiration.

#+BEGIN_SRC go
// DurationWithThreshold returns a gocmp.Comparer for comparing time.Duration. The
// Comparer returns true if the difference between the two Duration values is
// within the threshold and neither value is zero.
func DurationWithThreshold(threshold time.Duration) gocmp.Option {
        return gocmp.Comparer(cmpDuration(threshold))
}

func cmpDuration(threshold time.Duration) func(x, y time.Duration) bool {
        return func(x, y time.Duration) bool {
                if x == 0 || y == 0 {
                        return false
                }
                delta := x - y
                return delta <= threshold && delta >= -threshold
        }
}
#+END_SRC

Another good example for those options is when you want to skip some field. In [[https://github.com/docker/docker][=docker/docker=]] we want to be able to
easily check for equality between two service specs, but those might have different =CreatedAt= and =UpdatedAt= values
that we usually don't care about â€“ what we want is to make sure it happens in the past 20 seconds. You can easily define
an option for that.

#+BEGIN_SRC go
  func cmpServiceOpts() cmp.Option {
          const threshold = 20 * time.Second

          // Apply withinThreshold only for the following fields
          metaTimeFields := func(path cmp.Path) bool {
                  switch path.String() {
                  case "Meta.CreatedAt", "Meta.UpdatedAt":
                          return true
                  }
                  return false
          }
          // have a 20s threshold for the time value that will be passed
          withinThreshold := cmp.Comparer(func(x, y time.Time) bool {
                  delta := x.Sub(y)
                  return delta < threshold && delta > -threshold
          })

          return cmp.FilterPath(metaTimeFields, withinThreshold)
  }
#+END_SRC

I recommend you look at the [[https://godoc.org/gotest.tools/assert/opt][gotest.tools/assert/opt]] documentation to see which one are defined and how to use them.

***** Errors with =Error=, =ErrorContains= and =ErrorType=

Checking for errors is *very common* in Go, having =Comparison= function for it was a requirement.

- =Error= fails if the error is =nil= *or* the error message is not the expected one.
- =ErrorContains= fails if the error is =nil= *or* the error message does not contain the expected substring.
- =ErrorType= fails if the error is =nil= *or* the error type is not the expected type.

Let's first look at the most used : =Error= and =ErrorContains=.

#+BEGIN_SRC go
  var err error
  // will fail with : expected an error, got nil
  assert.Check(t, cmp.Error(err, "message in a bottle"))
  err = errors.Wrap(errors.New("other"), "wrapped")
  // will fail with : expected error "other", got "wrapped: other"
  assert.Check(t, cmp.Error(err, "other"))
  // will succeed
  assert.Check(t, cmp.ErrorContains(err, "other"))
#+END_SRC

As you can see =ErrorContains= is especially useful when working with /wrapped/ errors.
Now let's look at =ErrorType=.

#+BEGIN_SRC go
  var err error
  // will fail with : error is nil, not StubError
  assert.Check(t, cmp.ErrorType(err, StubError{}))

  err := StubError{"foo"}
  // will succeed
  assert.Check(t, cmp.ErrorType(err, StubError{}))

  // Note that it also work with a function returning an error
  func foo() error {}
  assert.Check(t, cmp.ErrorType(foo, StubError{}))
#+END_SRC

***** Bonus with =Panics=

Sometimes, a code is supposed to /panic/, see [[https://golang.org/doc/effective_go.html#panic][Effective Go (#Panic)]] for more information. And thus, you may want to make
sure you're code panics in such cases. It's always a bit tricky to test a code that panic as you have to use a deferred
function to recover the panic â€” but then if the panic doesn't happen how do you fail the test ?

This is where =Panics= comes handy.

#+BEGIN_SRC go
  func foo(shouldPanic bool) {
          if shouldPanic {
                  panic("booooooooooh")
          }
          // don't worry, be happy
  }
  // will fail with : did not panic
  assert.Check(t, cmp.Panics(foo(false)))
  // will succeed
  assert.Check(t, cmp.Panics(foo(true)))
#+END_SRC

***** Miscellaneous with =Contains=, =Len= and =Nil=

Those last three /built-in/ =Comparison= are pretty straightforward.

- =Contains= succeeds if item is in collection. Collection may be a string, map, slice, or array.

  If collection is a string, item must also be a string, and is compared using =strings.Contains()=. If collection is a
  Map, contains will succeed if item is a key in the map. If collection is a slice or array, item is compared to each
  item in the sequence using ==reflect.DeepEqual()==.
- =Len= succeeds if the sequence has the expected length.
- =Nil= succeeds if obj is a nil interface, pointer, or function.

#+BEGIN_SRC go
  // Contains works on string, map, slice or arrays
  assert.Check(t, cmp.Contains("foobar", "foo"))
  assert.Check(t, cmp.Contains([]string{"a", "b", "c"}, "b"))
  assert.Check(t, cmp.Contains(map[string]int{"a": 1, "b": 2, "c": 4}, "b"))

  // Len also works on string, map, slice or arrays
  assert.Check(t, cmp.Len("foobar", 6))
  assert.Check(t, cmp.Len([]string{"a", "b", "c"}, 3))
  assert.Check(t, cmp.Len(map[string]int{"a": 1, "b": 2, "c": 4}, 3))

  // Nil
  var foo *MyStruc
  assert.Check(t, cmp.Nil(foo))
  assert.Check(t, cmp.Nil(bar()))
#+END_SRC

But let's not waste more time and let's see how to write our own =Comparison= !

***** Write your own =Comparison=

One of the main aspect of =gotest.tools/assert= is to make it easy for developer to write as less boilerplate code as
possible while writing tests. Writing your own =Comparison= allows you to write a well named function that will be easy
to read and that can be re-used across your tests.

Let's look back at the =cmp.Comparison= and =cmp.Result= types.

#+BEGIN_SRC go
type Comparison func() Result

type Result interface {
        Success() bool
}
#+END_SRC

A =Comparison= for =assert.Check= or =assert.Check= is a function that return a =Result=, it's pretty straightforward to
implement, especially with =cmp.ResultSuccess= and =cmp.ResultFailure(â€¦)= (as seen previously).

#+BEGIN_SRC go
  func regexPattern(value string, pattern string) cmp.Comparison {
          return func() cmp.Result {
                  re := regexp.MustCompile(pattern)
                  if re.MatchString(value) {
                          return cmp.ResultSuccess
                  }
                  return cmp.ResultFailure(
                          fmt.Sprintf("%q did not match pattern %q", value, pattern))
          }
  }

  // To use it
  assert.Check(t, regexPattern("12345.34", `\d+.\d\d`))
#+END_SRC

As you can see, it's pretty easy to implement, and you can do quite a lot in there easily. If a function call returns an
error inside of your =Comparison= function, you can use =cmp.ResultFromError= for example. Having something like
=assert.Check(t, isMyServerUp(":8080"))= is way more readable than a 30-line of code to check it.

**** Conclusionâ€¦

â€¦ and that's a wrap. We only looked at the =assert= package of [[https://gotest.tools][=gotest.tools=]] so far, but it's already quite a bit to process.

We've seen :
- the main functions provided by this package : =assert.Assert= and =assert.Check=
- some helper functions like =assert.NilError=, â€¦
- the =assert/cmp=, and =assert/opt= sub-package that allows you to write more custom =Comparison=

Next time, we'll look at the =skip= package, that is a really simple wrapper on top of =testing.Skip= function.

*** Golang testing â€” gotest.tools skip
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-09-01-gotest-tools-skip
:EXPORT_DATE: 2018-09-01
:END:

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =skip= package. This is a
really simple one so this should be quick.

#+BEGIN_QUOTE
=skip= provides functions for skipping a test and printing the source code of the
condition used to skip the test.
#+END_QUOTE

The package consists of only one function : =If=. The idea comes mainly from
[[https://github.com/docker/docker][=docker/docker=]] integration test suite, where we wanted to skip some test (or test suites)
given different context. By context I mean things like the system we are running on
(=Windows=, =Linux=, â€¦) or the capabilities of the running kernel or node (is =apparmor=
available or not on the current machine).

This =If= method takes a =testing.T= pointer and either a boolean, a function that
returns a boolean, *or* an expression.

#+BEGIN_SRC go
  // boolean
  //   --- SKIP: TestName (0.00s)
  //           skip.go:19: MissingFeature
  var MissingFeature bool
  skip.If(t, MissingFeature)

  // function
  //   --- SKIP: TestName (0.00s)
  //           skip.go:19: !IsExperimentalDaemon(dockerClient): daemon is not experimental
  skip.If(t, IsExperimentalDaemon(dockerClient), "daemon is not experimental")

  // expression
  //   --- SKIP: TestName (0.00s)
  //           skip.go:19: apiVersion < version("v1.24")
  skip.If(t, apiVersion < version("v1.24"))
#+END_SRC

There is few elements to note though :

- This package (as other parts of the =gotest.tools= packages), will try to look at source
  files to display the expression used (same goes for =assert=). This is usually not a
  problem because you run tests where the source code is. *However*, in the cases you
  generate a test binary to be executed later (Ã -la =kubernetes= or other projects), this
  can display a weird error message if the sources are not availableâ€¦ You shouldn't be
  worried too much about it, but it's better if you know :)
- The main reason to use =skip.If= is mainly for new contributors to get in quickly,
  *reducing potential friction of them running the tests on their environment*. The more
  the tests are written in a way they explicitely declare their requirements (and skipped
  if the environment does not meet those), the easier it makes contributors run your
  tests. *But*, this also means, you should try to measure the skipped tests on your
  continuous integration system to make sure you run all of them eventuallyâ€¦ otherwise
  it's dead code. /But more on that in later posts ðŸ˜‰/.

That's all for today folks, told you that was going to be quick.
*** Golang testing â€” gotest.tools golden
:PROPERTIES:
:EXPORT_FILE_NAME: 2018-09-06-gotest-tools-golden
:EXPORT_DATE: 2018-09-06
:END:

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =golden= package. This is a
[[/posts/2017-04-22-golang-testing-golden-file/][/quick follow-up/ on a previous =golden= post]], but focused on the =gotest.tools=
implementation. I'm gonna be quicker, please read that one if =golden= files is a new
concept for you.

#+BEGIN_QUOTE
Package =golden= provides tools for comparing large mutli-line strings.

Golden files are files in the =./testdata/= subdirectory of the package under test.
#+END_QUOTE

In the previous article, we described the problem, and how to fix it by writing a small
helper. Well, that small helper is in =gotest.tools/golden= now, and it has a tiny bit
more features.

One of the difference between the =gotest.tools= implementation and the previous post is
the flag name. In =gotest.tools/golden=, the flag is =-test.update-golden= (was just
=-test.update= before). Just as before, if the =-test.update-golden= flag is set then the
actual content is written to the golden file, before reading it and comparing.

There is two ways to use the =golden= package:
- on it's own, using =golden.Assert= or =golden.AssertBytes=
- as a =cmp.Comparison=, with =golden.String= or =golden.Bytes=

**** =Assert= and =AssertBytes=

Using =Assert= functions should be straightforward. Both =Assert= function compares the
actual content to the expected content in the golden file and returns whether the
assertion was successful (true) or not (false).

- =Assert= uses string. Note that this one *removes carriage return* before comparing to
  depend as less as possible of the system (=\n= vs =\r\n= ðŸ˜…)
- =AssertBytes= uses raw data (in the form of =[]byte=)

#+BEGIN_SRC go
  golden.Assert(t, "foo", "foo-content.golden")
  // Could also be used to check some binary format
  golden.AssertBytes(t, []byte("foo"), "foo-content.golden")
#+END_SRC

**** =Bytes= and =String=

As written in a [[/posts/2018-08-16-gotest-tools-assertions/][previous post (about the =assert= package)]], I prefer to use =cmp.Comparison=.

#+BEGIN_QUOTE
All those helper functions have a equivalent function in the =cmp= package that returns a
=Comparison=. I, personally, prefer to use =assert.Check= or =assert.Assert= in
combination with =cmp.Comparison= as it allows me to write all my assertions the same way,
with built-ins comparison or with my own â€” i.e. =assert.Assert(t, is.Equal(â€¦), "message"=
or =assert.Assert(t, stackIsUp(c, timeâ€¦), "another message")=.
#+END_QUOTE

The =golden= package gives us that too, in the form of =Bytes= and =String=. Using the
=assert.Check= or =assert.Assert= functions with those is equivalent to their /helper/
counter-part =golden.Assert= and =golden.AssertBytes=.

#+BEGIN_SRC go
  assert.Assert(t, golden.String("foo", "foo-content.golden"))
  // Could also be used to check some binary format
  assert.Assert(t, golden.Bytes([]byte("foo"), "foo-content.golden"))
#+END_SRC

**** Conclusionâ€¦

â€¦ that's a wrap. As for [[/posts/2018-09-01-gotest-tools-skip/][=skip=]], this is a small package, so the post was going to be
quick. =golden= package just solve a specific problem (read [[/posts/2017-04-22-golang-testing-golden-file/][Golang testing â€” golden file]])
in a simple way.

*** DRAFT Golang testing â€” gotest.tools fs

Let's continue the [[https://gotest.tools][=gotest.tools=]] serie, this time with the =fs= package.

#+BEGIN_QUOTE
Package fs provides tools for creating temporary files, and testing the contents and structure of a directory.
#+END_QUOTE

This package is heavily using functional arguments (as we saw in [[/posts/2017-01-01-go-testing-functionnal-builders/][functional arguments for
wonderful builders]]). Functional arguments is, in a nutshell, a combinaison of two Go
features : /variadic/ functions (=...= operation in a method signature) and the fact that
=func= are /first class citizen/. This looks more or less like that.

#+BEGIN_SRC go
  type Config struct {}

  func MyFn(ops ...func(*Config)) *Config {
          c := &Config{} // with default values
          for _, op := range ops {
                  op(c)
          }
          return c
  }

  // Calling it
  conf := MyFn(withFoo, withBar("baz"))
#+END_SRC

The =fs= package has too *main* purpose :

1. create folders and files required for testing in a simple manner
2. compare two folders structure (and content)

**** TODO Create folder structures

Sometimes, you need to create folder structures (and files) in tests. Doing =i/o= work
takes time so try to limit the number of tests that needs to do that, especially in unit
tests. Doing it in tests adds a bit of boilerplate that could be avoid. As stated [[/posts/2017-01-01-go-testing-functionnal-builders/][before]] :

#+BEGIN_QUOTE
One of the most important characteristic of a unit test (and any type of test really) is
*readability*. This means it should be easy to read but most importantly it should *clearly
show the intent* of the test. The setup (and cleanup) of the tests should be as small as
possible to avoid the noise.
#+END_QUOTE

The =fs= package intends to help with that and comes with a bunch function to create
folder structure :

- two main function =NewFile= and =NewDir=
- a bunch of /operators/ : =WithFile=, =WithDir=, â€¦

#+BEGIN_SRC go
  func NewDir(t assert.TestingT, prefix string, ops ...PathOp) *Dir {
          // â€¦
  }

  func NewFile(t assert.TestingT, prefix string, ops ...PathOp) *File {
          // â€¦
  }
#+END_SRC

**** TODO Compare folder structures

*** TODO Golang testing â€” gotest.tools icmd
*** TODO Golang testing â€” gotest.tools x/subtest
*** TODO gotestsum
https://github.com/gotestyourself/gotestsum
*** TODO gauge for readme-test-driven
*** TODO continuous testing with filewatcher, goconvey, â€¦
** Containerd                                :development:golang:@container:
** Emacs                                                     :editor:@emacs:
*** TODO Window pop-up                                      :buffer:window:

** NixOS                                                        :nixos:@nix:
*** TODO Intro - general configuration

*** TODO =home-manager=
* Posts
** TODO On getting more work done
*** TODO notes/ideas
- Remove slack from phone (or personal tablets)
  With working remote, it's even more important to draw the line

- Have timeboxed Â« slacking off Â» session
  by slacking off, I mean twitter, reddit, â€¦

- Take a medium to long walk during the day
  Better in the middle, by medium to long I mean at least an hour walk
*** TODO Pomodoro technique

- It's ok to set smaller pomodoro from time to time, 25 is the "longest" limit, not the
  lowest one

- Apply it as much as you can (i.e. not interruption)

*** Refs
- https://thelifelifebalance.com/pros-and-cons-of-pomodoro/
** TODO Why I like fish abbrs                                        :quick:
** TODO nixos, binfmt_misc and containers
*** References
- https://www.kernel.org/doc/html/v4.14/admin-guide/binfmt-misc.html
- https://github.com/genuinetools/binctr
- https://blog.jessfraz.com/post/nerd-sniped-by-binfmt_misc/
** TODO Tool of the day =prm=
** TODO wincent/clipper
** TODO nixos, runc, systemctl --user
Run rootless containers with runc and services with systemctl
** TODO Quick and dirty linux/distribution isolation

*** References
- https://unix.stackexchange.com/questions/10743/what-to-do-to-run-gui-java-app-in-chrooted-environment
- https://ebzzry.io/en/zsh-tips-3/
- https://ebzzry.io/en/kvm/
- http://wiki.ros.org/docker/Tutorials/GUI
