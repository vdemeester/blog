#+hugo_base_dir: ../
#+hugo_section: posts
#+seq_todo: TODO DRAFT NONE

#+options: creator:t

* Blog Ideas
** TODO Notary series

* Series
** Golang testing                             :@developement:testing:golang:
*** DRAFT Golang testing ‚Äî functional arguments for wonderful builders :functionnal:java:builder:
:PROPERTIES:
:EXPORT_FILE_NAME: 2017-01-01-go-testing-functonnal-builders
:EXPORT_DATE: 2017-01-01
:END:
#+BEGIN_QUOTE
Programming is not easy; even the best programmers are incapable of
writing programs that work exactly as intended every time. Therefore
an important part of the software development process is
testing. Writing tests for our code is a good way to ensure quality
and improve reliability.
#+END_QUOTE

Go programs, when properly implemented, are fairly simple to test
programatically. The =testing= built-in library and the features of
the language itself offer plenty of ways to write good tests. As this
is a subject I particularly like, I'm gonna write a bunch of articles
about it, that, /hopefully/ do not get old or boring.

I'm not going to start by introducing how =testing= works, it's
already widely described in [[https://golang.org/pkg/testing/][the =testing= godoc]], [[https://blog.golang.org/examples][some]] [[https://www.golang-book.com/books/intro/12][articles]] and
[[https://jonathanmh.com/golang-unit-testing-for-absolute-beginners/][blogs]]. I'm going to jump ahead on a more advanced techinque to write
tests, the =builders= for tests.

One of the most important characteristic of a *unit test* (and any
type of test really) is *readability*. This means it should be /easy
to read/ but most importantly it should *clearly show the intent of
the test*. The setup (and cleanup) of the tests should be as small as
possible to avoid the noise. And as we are going to see below, =go=
makes it pretty easy to do so.

**** Builders in tests

  Sometimes, your need to create data structure for your test that
  might take a lot of line and introduce noise. In =golang= we don't
  have method overload or even /constructors/ as some other language
  have. This means most of the time, we end up building our data using
  directly the struct expression, as below.

  #+BEGIN_SRC go :hl_lines 1,3-5
  node := &Node{
          Name: "carthage",
          Hostname: "carthage.sbr.pm",
          Platform: Platform{
                  Architecture: "x86_64",
                  OS:           "linux",
          },
  }
  #+END_SRC

  Let's imagine we have a =Validate= function that make sure the
  specified =Node= is supported on our structure. We would write some
  tests that ensure that.

  #+BEGIN_SRC go
    func TestValidateLinuxIsSupported(t *testing.T) {
            valid := Validate(&Node{
                    Name: "carthage",
                    Hostname: "carthage.sbr.pm",
                    Platform: &Platform{
                            Architecture: "x86_64",
                            OS:           "linux",
                    },
            })
            if !valid {
                    t.Fatal("linux should be supported, it was not")
            }
    }

    func TestValidateDarwinIsNotSupported(t *testing.T) {
            valid := Validate(&Node{
                    Name: "babylon",
                    Hostname: "babylon.sbr.pm",
                    Platform: &Platform{
                            Architecture: "x86_64",
                            OS:           "darwin",
                    },
            })
            if valid {
                    t.Fatal("darwin should not be supported, it was")
            }
    }
  #+END_SRC

  This is quickly hard to read, there is too much noise on that
  test. We setup a whole =Node= struct, but the only thing we really
  intend to test is the =Platform.OS= part. The rest is just required
  fields for the function to correctly compile and run.

  This is where test builders (and builders in general) comes into
  play. In [[http://www.growing-object-oriented-software.com/][Growing Object-Oriented Software Guided by Tests]], the
  Chapter 22 "Constructing Complex Test Data" is exactly about that
  and guide us through the why and the how of these builders. The
  examples in the book are in =java= and uses wisely the
  object-oriented nature of the language. Here is an example from the
  book.

  #+BEGIN_SRC java
    // I just want an order from a customer that has no post code
    Order order = anOrder()
        .from(aCustomer().with(anAddress().withNotPostCode()))
        .build()
  #+END_SRC

  These builders helps *keep tests expressive*, as it's pretty obvious
  when reading it, what we want to test. They remove the *visual
  noise* you have when building an object (or a =struct{}= in Go) and
  allows you to put sane default. They also make *tests resilient to
  change*. If the structure changes, only the builder has to be
  updated, not the tests depending on it. They also make default case
  really simple to write, and special cases not much more complicated.

**** Builder in Go

  The naive way to create builders in =go= could be to create a
  =builder= struct that have methods to construct the final struct and
  a =build= method. Let's see how it looks.

  #+BEGIN_SRC go
    func ANode() *NodeBuilder {
            return &NodeBuilder{
                    node: &Node{
                            Name: "node",
                            // Other defaults
                    },
            }
    }

    type NodeBuilder struct {
            node *Node
    }

    func (b *NodeBuilder) Build() *Node {
            return b.node
    }

    func (b *NodeBuilder) Hostname(hostname string) *NodeBuilder {
            b.node.Hostname = hostname
            return b
    }

    func (b *NodeBuilder) Name(name string) *NodeBuilder {
            b.node.Name = name
            return b
    }

    func (b *NodeBuilder) Platform(platform *Platform) *NodeBuilder {
            b.node.Platform = platform
            return b
    }
  #+END_SRC

  This looks decent, and using it is pretty straightforward. At least
  it make building the =struct= more expressive, less noisy and
  resilient to change. We can update the previous test as follow.

  #+BEGIN_SRC go
    func TestValidateLinuxIsSupported(t *testing.T) {
            valid := Validate(ANode().Platform(&Platform{
                    Architecture: "x86_64",
                    OS:           "linux",
            }).Build())
            if !valid {
                    t.Fatal("linux should be supported, it was not")
            }
    }

    func TestValidateDarwinIsNotSupported(t *testing.T) {
            valid := Validate(ANode().Platform(&Platform{
                    Architecture: "x86_64",
                    OS:           "darwin",
            }).Build())
            if valid {
                    t.Fatal("darwin should not be supported, it was")
            }
    }
  #+END_SRC

  There is room for improvement :

  - There is still some noise, mainly =build()= and the platform
    =struct=, as it still shows too much.
  - It's not that extensible yet. If you want to update the =Node= a
    certain way that the builder is not written for, you have to
    update the builder.
  - The =NodeBuilder= struct feels a little empty, it's just there to
    hold on the =Node= being constructed until it is =build=.

  One improvement we could make is to have a =Platform= builder, even
  if it's a small struct here. Let's do that in the same way we did
  with =Node=.

  #+BEGIN_SRC go
    func APlatform() *PlatformBuilder {
            return &PlatformBuilder{
                    platform: &Platform{
                            Architecture: "x64_86",
                            OS: "linux",
                    },
            }
    }

    type PlatformBuilder struct{
            platform *Platform
    }

    func (b *PlatformBuilder) Build() *Platform {
            return b.platform
    }

    func (b *PlatformBuilder) OS(os string) *PlatformBuilder {
            b.platform.OS = os
            return b
    }
  #+END_SRC

  And our tests becomes üêª.

  #+BEGIN_SRC go
    func TestValidateLinuxIsSupported(t *testing.T) {
            valid := Validate(ANode().Platform(
                    APlatform().OS("linux").Build()
            ).Build())
            if !valid {
                    t.Fatal("linux should be supported, it was not")
            }
    }

    func TestValidateDarwinIsNotSupported(t *testing.T) {
            valid := Validate(ANode().Platform(
                    APlatform().OS("darwin").Build()
            ).Build())
            if valid {
                    t.Fatal("darwin should not be supported, it was")
            }
    }
  #+END_SRC

  It does not really improve the visual noise as there is now quite a
  few duplication : several =build=, =APlatform= inside =Platform=, ‚Ä¶
  It is a small improvement on readability but not that much compared
  to the previous one. This is were the Go language features comes
  into play.

**** Functional arguments to the rescue

  Go has two interesting feature that are going to be useful here.

  First, a function in Go is a type on its own and thus is considered
  a /first class citizen/. It means it's possible to pass a function
  as argument, or define a variable that holds it.

  #+BEGIN_SRC go
    func ApplyTo(s string, fn func(string) string) string {
            return fn(s)
    }

    func world(s string) string {
            return fmt.Sprintf("%s, world!", s)
    }

    // Usage
    a := ApplyTo("hello", world)
    // a == "hello, world!"
  #+END_SRC

  The second feature that comes into play here, is the possiblity to
  have /variadic/ functions. A variadic function is a function that
  takes a variable number of arguments (from =0= to any number of
  argument).

  #+BEGIN_SRC go
    func Print(strs ...string) string {
            for _, s := range strs {
                    fmt.Println(s)
            }
    }
  #+END_SRC

  As we are going to see below, combining these two feature makes our
  builders pretty easy to write and to use with simple case, while
  staying very customizable, even outside of the builder. This is
  really well described in a talk from Dave Cheney : [[https://www.youtube.com/watch?v%3D24lFtGHWxAQ&index%3D15&list%3DPLMW8Xq7bXrG58Qk-9QSy2HRh2WVeIrs7e][Functional
  options for friendly APIs]] ([[https://dave.cheney.net/2014/10/17/functional-options-for-friendly-apis][transcription]]).

  Let's apply that to our new builders.

  #+BEGIN_SRC go
    func ANode(nodeBuilders ...func(*Node)) *Node {
            node := &Node{
                    Name: "node",
                    // Other defaults
            }

            for _, build := range nodeBuilders {
                    build(node)
            }

            return node
    }

    func APlatform(platformBuilders ...func(*Platform)) *Platform {
            platform := &Platform{
                    Architecture: "x64_86",
                    OS: "linux",
            }

            for _, build := range platformBuilders {
                    build(platform)
            }

            return platform
    }
  #+END_SRC

  And that is it for the actual builder code. It is *small* and
  simple, there is *no more =NodeBuilder=* struct, and this is highly
  extensible. Let's see how to use it.

  #+BEGIN_SRC go
    // a default node
    node1 := ANode()
    // a node with a specific Hostname
    node2 := ANode(func(n *Node) {
            n.Hostname = "custom-hostname"
    })
    // a node with a specific name and platform
    node3 := ANode(func(n *Node) {
            n.Name = "custom-name"
    }, func (n *Node) {
            n.Platform = APlatform(func (p *Platform) {
                    p.OS = "darwin"
            })
    })
  #+END_SRC

  The last step is to define some /function builder/ for common or
  widely used customization, to make this *expressive*. And let
  complex, /one-time/ function builder in the end of the user. Now our
  tests looks like.

  #+BEGIN_SRC go
    func TestValidateLinuxIsSupported(t *testing.T) {
            valid := Validate(ANode(WithAPlatform(Linux)))
            if !valid {
                    t.Fatal("linux should be supported, it was not")
            }
    }

    func TestValidateDarwinIsNotSupported(t *testing.T) {
            valid := Validate(ANode(WithAPlatform(Darwin)))
            if valid {
                    t.Fatal("darwin should not be supported, it was")
            }
    }

    // Function builders
    func WithAPlatform(builders ...func(*Platform)) func (n *Node) {
            return func(n *Node) {
                    n.Platform = Platform(builders...)
            }
    }

    func Linux(p *Platform) {
            p.OS = "linux"
    }

    func Darwin(p *Platform) {
            p.OS = "darwin"
    }
  #+END_SRC

  The intent is now clear. It's readable and still resilient to
  change. The code =Node(WithPlatform(Linux))= is easy to understand
  for a human. It makes what are the /tested/ characteristics of
  =struct= pretty clear. It's easy to combine multiple builders as the
  =WithPlatform= function shows üëº. It's also easy to create a
  /function builder/, even in a different package (as long as the ways
  to modify the struct are exported) and complex or /on-off/ builder
  can be embedded in the function call (=Node(func(n *Node) { // ‚Ä¶
  })=).

  In summary, using these types of builder have several advantages :

  - tests are *easy to read*, and reduce the visual noise
  - tests are *resilient to change*
  - builders are *easy to compose* and very extensible
  - builders could even be *shared* with production code as there is
    nothing tied to =testing=.

*** DRAFT Golang testing ‚Äî golden file
:PROPERTIES:
:EXPORT_FILE_NAME: golang-testing-golden-file
:EXPORT_DATE: 2018-04-22T09:50:21-05:00
:END:

Tests are all about *maintainability* and *readability*. You want the least visual noise possible and it should not be a
hassle to maintain. When testing functions that output a long of string, in case of a command line output testing,
readability and maintainance tend to be tricky to achieve.
